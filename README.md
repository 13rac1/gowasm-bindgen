# go-wasm-ts-gen

Generate TypeScript declaration files from Go unit tests for WASM exports.

## Overview

**go-wasm-ts-gen** is a zero-annotation TypeScript type generation tool for Go WASM modules. It extracts function signatures directly from your existing unit testsâ€”no special comments, tags, or annotations required.

Instead of maintaining separate type definitions or adding build-time annotations, write tests that call your WASM functions and this tool will generate accurate TypeScript `.d.ts` files automatically. Works with both table-driven tests and simple direct calls.

## Installation

```bash
go install github.com/13rac1/go-wasm-ts-gen/cmd/go-wasm-ts-gen@latest
```

## Usage

```bash
go-wasm-ts-gen --tests "cmd/wasm/*_test.go" --output types.d.ts
```

### Flags

- `--tests` (required): Glob pattern for test files (can be specified multiple times)
- `--output` (required): Output `.d.ts` file path

### Example

```bash
# Generate types from a single test file
go-wasm-ts-gen --tests "wasm/main_test.go" --output wasm/types.d.ts

# Generate types from multiple test files
go-wasm-ts-gen \
  --tests "wasm/*_test.go" \
  --tests "wasm/helpers/*_test.go" \
  --output dist/types.d.ts
```

### Output

The tool provides verbose output showing what it found:

```
Parsing test files...

Found 2 WASM function(s):

  greet (wasm/main_test.go:15)
    Parameters:
      - name: string
    Return type: string

  add (wasm/main_test.go:35)
    Parameters:
      - a: number
      - b: number
    Return type: number

Generated types.d.ts with 2 function(s)
```

## How It Works

The tool analyzes Go test files and extracts WASM function signatures through a multi-stage process:

1. **Parse Go test files** using `go/parser` to build an AST
2. **Find Test functions** that contain WASM call patterns
3. **Extract parameter types** from `js.ValueOf()` calls in test code
4. **Extract parameter names** from:
   - Table-driven test struct field names (preferred)
   - Variable names in `js.ValueOf(varName)` expressions
   - Fallback to `arg0`, `arg1`, etc. for literals
5. **Infer return types** from result handling methods like `.String()`, `.Int()`, `.Bool()`
6. **Validate patterns** and fail with clear errors if malformed
7. **Generate TypeScript declarations** with JSDoc comments containing usage examples

### Input Example (Go Test)

```go
func TestGreet(t *testing.T) {
    tests := []struct {
        name string
        want string
    }{
        {name: "World", want: "Hello, World!"},
        {name: "Go", want: "Hello, Go!"},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := greet(js.Null(), []js.Value{
                js.ValueOf(tt.name),
            })
            if result != tt.want {
                t.Errorf("got %v, want %v", result, tt.want)
            }
        })
    }
}

func TestAdd(t *testing.T) {
    tests := []struct {
        a, b int
        want int
    }{
        {a: 1, b: 2, want: 3},
        {a: -1, b: 1, want: 0},
    }
    for _, tt := range tests {
        result := add(js.Null(), []js.Value{
            js.ValueOf(tt.a),
            js.ValueOf(tt.b),
        })
        if result != tt.want {
            t.Errorf("got %v, want %v", result, tt.want)
        }
    }
}
```

### Output Example (TypeScript)

```typescript
/**
 * Auto-generated TypeScript declarations for Go WASM exports
 * Generated by go-wasm-ts-gen
 */
/**
 * @example
 * // "World"
 * greet()
 * @example
 * // "Go"
 * greet()
 */
declare global {
  interface Window {
    greet(name: string): any;
  }
}
declare global {
  interface Window {
    add(a: number, b: number): any;
  }
}
export {};
```

## Type Mapping

The tool maps Go types to TypeScript according to this table:

| Go Type | TypeScript Type |
|---------|-----------------|
| `string` | `string` |
| `int`, `int8`, `int16`, `int32`, `int64` | `number` |
| `uint`, `uint8`, `uint16`, `uint32`, `uint64` | `number` |
| `float32`, `float64` | `number` |
| `bool` | `boolean` |
| `[]T` | `T[]` |
| `map[string]T` | `{[key: string]: T}` |
| Other types | `any` |

## Requirements

### Parameter Names

Parameter names are extracted in order of preference:

**1. Table-driven test struct fields (best):**
```go
tests := []struct {
    username string  // Parameter name: "username"
    age      int     // Parameter name: "age"
    want     string
}{
    {username: "alice", age: 30, want: "Alice (30)"},
}
```

**2. Variable names in js.ValueOf():**
```go
func TestGreet(t *testing.T) {
    userName := "Alice"
    result := greet(js.Null(), []js.Value{
        js.ValueOf(userName),  // Parameter name: "userName"
    })
}
```

**3. Fallback:** If using literals like `js.ValueOf("hello")` or `js.ValueOf(42)`, parameters are named `arg0`, `arg1`, etc.

### WASM Call Pattern

Tests must call functions with the standard Go WASM signature:

```go
func myFunc(this js.Value, args []js.Value) interface{}
```

And pass arguments using `js.ValueOf()`:

```go
result := myFunc(js.Null(), []js.Value{
    js.ValueOf(param1),
    js.ValueOf(param2),
})
```

### Return Type Inference

Return types are inferred from how test code accesses the result:

```go
result.String()     // infers: string
result.Int()        // infers: number
result.Bool()       // infers: boolean
result.Get("key")   // infers: any (object/map)
```

If no accessor method is found, the return type defaults to `any`.

## Error Handling

The tool validates WASM call patterns and fails fast with clear error messages:

```
error: found 2 malformed WASM call pattern(s):
  wasm/broken_test.go:15: function has 3 arguments, expected exactly 2 (badFunc)
  wasm/broken_test.go:25: first argument is not js.Null() (anotherFunc)

Expected pattern:
  result := funcName(js.Null(), []js.Value{js.ValueOf(arg), ...})
```

### Detected Errors

| Error | Cause |
|-------|-------|
| `function has N arguments, expected exactly 2` | Wrong number of arguments |
| `first argument is not js.Null()` | Missing or wrong first argument |
| `second argument is not []js.Value{...}` | Args not passed as slice literal |
| `function is method/selector` | Using `pkg.Func()` instead of `Func()` |
| `call is not assigned to a variable` | Missing `result :=` assignment |
| `return type inferred as 'any'` | No result accessor methods found |

## Limitations

- **Only supports js.Value-based WASM patterns** (standard Go WASM signature)
- **Return type inference is heuristic-based** and may default to `any` for complex types
- **No support for function overloads** (Go doesn't support them either)
- **Complex nested types** (nested objects, unions) may need manual refinement
- **No runtime validation** of generated types against actual WASM behavior

## Development

### Build

```bash
make build
```

### Test

```bash
make test
```

### Lint and Format

```bash
make format
make lint
```

### Full Check (format + lint + test)

```bash
make check
```

### End-to-End Test

Runs the complete workflow: build WASM, generate types, verify with Deno:

```bash
make test-e2e
```

### Clean

Remove build artifacts and generated test files:

```bash
make clean
```

## License

MIT

## Contributing

Contributions are welcome! Please ensure all tests pass (`make check`) before submitting a pull request.
