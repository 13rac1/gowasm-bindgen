# gowasm-bindgen

**Type-safe Go in the browser.**

Generate TypeScript declarations and Go WASM bindings from your Go source code. Ship 90KB gzipped binaries with TinyGo.

## The Problem

Go WASM functions are invisible to TypeScript:

```typescript
// TypeScript has no idea what this returns or accepts
const result = window.myGoFunction(???, ???);  // any
```

Standard Go WASM binaries are huge (~2.4MB), and WASM runs synchronously on the main thread, blocking your UI.

## The Solution

**gowasm-bindgen** generates bindings from your normal Go functions:

```go
// main.go - Write normal Go functions
package main

// User represents a user
type User struct {
    Name   string `json:"name"`
    Age    int    `json:"age"`
    Active bool   `json:"active"`
}

// Greet returns a greeting message
func Greet(name string) string {
    return "Hello, " + name + "!"
}

// FormatUser creates a formatted user
func FormatUser(name string, age int, active bool) User {
    return User{Name: name, Age: age, Active: active}
}
```

Generates `client.ts` with a clean, type-safe API and `bindings_gen.go` with WASM wrappers:

```typescript
// client.ts - Generated by gowasm-bindgen
export interface FormatUserResult {
  name: string;
  age: number;
  active: boolean;
}

export class Main {
  static async init(workerUrl: string): Promise<Main>;
  Greet(name: string): Promise<string>;
  FormatUser(name: string, age: number, active: boolean): Promise<FormatUserResult>;
  terminate(): void;
}
```

```go
// bindings_gen.go - Generated Go WASM wrappers
func init() {
    js.Global().Set("greet", js.FuncOf(wasmGreet))
    js.Global().Set("formatUser", js.FuncOf(wasmFormatUser))
}

func wasmGreet(_ js.Value, args []js.Value) interface{} {
    name := args[0].String()
    return Greet(name)
}

func wasmFormatUser(_ js.Value, args []js.Value) interface{} {
    name := args[0].String()
    age := args[1].Int()
    active := args[2].Bool()
    result := FormatUser(name, age, active)
    return map[string]interface{}{
        "name": result.Name,
        "age": result.Age,
        "active": result.Active,
    }
}
```

With TinyGo, your WASM binary drops from 2.4MB to **200KB (90KB gzipped)**, and Web Workers keep your UI responsive.

## Quick Start

```bash
# Install
go install github.com/13rac1/gowasm-bindgen/cmd/gowasm-bindgen@latest

# Generate TypeScript client and Go bindings
gowasm-bindgen main.go --output client.ts --go-output bindings_gen.go
# Creates: client.ts (async API) + worker.js (Web Worker) + bindings_gen.go (Go wrappers)

# Or generate synchronous API (blocks main thread)
gowasm-bindgen main.go --output client.ts --go-output bindings_gen.go --sync
# Creates: client.ts only (sync API) + bindings_gen.go (Go wrappers)

# Or just TypeScript without Go bindings
gowasm-bindgen main.go --output client.ts
# Creates: client.ts + worker.js (you write WASM wrappers manually)
```

**Usage in TypeScript:**

```typescript
// Worker mode (default) - non-blocking
import { Main } from './client';

const wasm = await Main.init('./worker.js');
const greeting = await wasm.Greet('World');  // runs in worker
const user = await wasm.FormatUser('Alice', 30, true);
wasm.terminate();

// Sync mode (--sync flag) - blocks main thread
import { Main } from './client';

const wasm = await Main.init('./example.wasm');  // async load
const greeting = wasm.Greet('World');  // sync call (no await)
const user = wasm.FormatUser('Alice', 30, true);
```

## Get Started

Choose your path:

- **[For TypeScript Developers](docs/for-typescript-devs.md)** — Run Go in your frontend in 10 minutes
- **[For Go Developers](docs/for-go-devs.md)** — Full-stack Go with proper JS types

## See It Working

The [example/](example/) directory has a complete demo:

```bash
cd example
make all    # Build WASM, generate types, verify, compile TypeScript
make serve  # Open http://localhost:8080
```

## How It Works

1. Parse your Go source file
2. Find exported functions (capitalized names with no receiver)
3. Extract parameter names and types from function signatures
4. Extract return types, supporting structs with JSON tags and (T, error) patterns
5. Generate `client.ts` with a type-safe TypeScript API
6. Generate `bindings_gen.go` with WASM wrapper functions that handle type conversions
7. Generate `worker.js` for async/non-blocking calls (default) or sync mode with `--sync`

No annotations. No build plugins. Just normal Go code.

## Requirements

- Go 1.21+
- [TinyGo](https://tinygo.org/getting-started/install/) (recommended for small binaries) or standard Go
- Node.js 18+ (for TypeScript verification and example demo)
- Write normal exported Go functions - the tool generates the WASM wrappers for you

**Note**: TinyGo produces much smaller binaries but has [language limitations](https://tinygo.org/docs/reference/lang-support/). Use standard Go if you need full reflection or unsupported features.

## Supported Types

- **Primitives**: string, int, int8-64, uint, uint8-64, float32/64, bool
- **Slices**: []T where T is any supported type
- **Maps**: map[string]T where T is any supported type
- **Structs**: Custom types with JSON tags for field naming
- **Errors**: (T, error) return patterns automatically generate error handling
- **Pointers**: Automatically dereferenced

## Limitations

See [LIMITATIONS.md](LIMITATIONS.md) for a comparison with Rust's wasm-bindgen and current gaps. Highlights:

- Worker mode is default (async Promise-based), use `--sync` for synchronous blocking calls
- No typed arrays (requires string serialization)
- No callbacks or closures
- Class-based API (methods on class instances)

## License

MIT
