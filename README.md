# gowasm-bindgen

**Type-safe Go in the browser.**

Generate TypeScript declarations from your Go tests. Ship 90KB gzipped binaries with TinyGo.

## The Problem

Go WASM functions are invisible to TypeScript:

```typescript
// TypeScript has no idea what this returns or accepts
const result = window.myGoFunction(???, ???);  // any
```

Standard Go WASM binaries are huge (~2.4MB), and WASM runs synchronously on the main thread, blocking your UI.

## The Solution

**gowasm-bindgen** extracts types from your existing Go tests:

```go
// Your Go test
func TestGreet(t *testing.T) {
    tests := []struct {
        name string  // ← parameter name
        want string
    }{
        {name: "World", want: "Hello, World!"},
    }
    for _, tt := range tests {
        result := greet(js.Null(), []js.Value{
            js.ValueOf(tt.name),  // ← type: string
        })
        jsResult := result.(js.Value)
        got := jsResult.String()  // ← return type: string
        // ...
    }
}
```

Generates `client.ts` with a clean, class-based API:

```typescript
// client.ts - Generated by gowasm-bindgen
export class Wasm {
  static async init(workerUrl: string): Promise<Wasm>;
  greet(name: string): Promise<string>;
  terminate(): void;
}
```

With TinyGo, your WASM binary drops from 2.4MB to **200KB (90KB gzipped)**, and Web Workers keep your UI responsive.

## Quick Start

```bash
# Install
go install github.com/13rac1/gowasm-bindgen/cmd/gowasm-bindgen@latest

# Generate Web Worker wrapper (default - non-blocking, Promise-based)
gowasm-bindgen --tests "wasm/*_test.go" --output client.ts
# Creates: client.ts (class API) + worker.js (Web Worker)

# Or generate synchronous API (blocks main thread)
gowasm-bindgen --tests "wasm/*_test.go" --output client.ts --sync
# Creates: client.ts only (sync calls)
```

**Usage in TypeScript:**

```typescript
// Worker mode (default) - non-blocking
import { Wasm } from './client';

const wasm = await Wasm.init('./worker.js');
const greeting = await wasm.greet('World');  // runs in worker
wasm.terminate();

// Sync mode (--sync flag) - blocks main thread
import { Wasm } from './client';

const wasm = await Wasm.init('./example.wasm');  // async load
const greeting = wasm.greet('World');  // sync call (no await)
```

## Get Started

Choose your path:

- **[For TypeScript Developers](docs/for-typescript-devs.md)** — Run Go in your frontend in 10 minutes
- **[For Go Developers](docs/for-go-devs.md)** — Full-stack Go with proper JS types

## See It Working

The [example/](example/) directory has a complete demo:

```bash
cd example
make all    # Build WASM, generate types, verify, compile TypeScript
make serve  # Open http://localhost:8080/web/
```

## How It Works

1. Parse your Go test files
2. Find WASM function calls (`funcName(js.Null(), []js.Value{...})`)
3. Extract parameter names from struct fields or variable names
4. Extract parameter types from `js.ValueOf()` calls
5. Infer return types from result accessors (`.String()`, `.Int()`, `.Bool()`, `.Get()`)
6. Generate `client.ts` with a class-based API (class name from Go package)
7. Generate `worker.js` for async/non-blocking calls (default) or sync mode with `--sync`

No annotations. No build plugins. Just tests.

## Requirements

- Go 1.21+
- [TinyGo](https://tinygo.org/getting-started/install/) (recommended for small binaries) or standard Go
- Node.js 18+ (for TypeScript verification and example demo)
- Your WASM functions must use the standard signature: `func(js.Value, []js.Value) interface{}`

**Note**: TinyGo produces much smaller binaries but has [language limitations](https://tinygo.org/docs/reference/lang-support/). Use standard Go if you need full reflection or unsupported features.

## Limitations

See [LIMITATIONS.md](LIMITATIONS.md) for a comparison with Rust's wasm-bindgen and current gaps. Highlights:

- Worker mode is default (async Promise-based), use `--sync` for synchronous blocking calls
- No typed arrays (requires string serialization)
- No callbacks or closures
- Class-based API (methods on class instances)

## License

MIT
