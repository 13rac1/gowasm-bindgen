# gowasm-bindgen for TypeScript Developers

You know TypeScript. You're curious about Go. Here's how to run Go code in your browser with full type safety.

## Why Go in the Browser?

- **Performance**: Go compiles to WebAssembly, running at near-native speed
- **Shared logic**: Use the same code on your backend and frontend
- **Type safety**: With gowasm-bindgen, your Go functions get proper TypeScript types
- **Non-blocking**: Web Worker mode keeps your UI responsive

## What You Need to Know

Your Go teammate writes normal Go functions with standard types. gowasm-bindgen reads the source code and generates TypeScript bindings automatically. You import the generated `client.ts` class. That's it.

**The files you care about:**

| File | What it is |
|------|------------|
| `example.wasm` | The compiled Go code (runs in Web Worker) |
| `worker.js` | Generated Web Worker script (loads and runs WASM) |
| `client.ts` | Generated TypeScript class (your API with full types) |

All files are generated by gowasm-bindgen or your build process.

## Using the Generated Class API

### 1. Import and initialize

```typescript
import { Main } from './generated/client';

// Initialize with the Web Worker URL
const wasm = await Main.init('./worker.js');
```

### 2. Call Go functions with full type checking

```typescript
// TypeScript knows: greet(name: string): Promise<string>
const greeting = await wasm.greet("World");
console.log(greeting);  // "Hello, World!"

// TypeScript knows: calculate(a: number, b: number, op: string): Promise<number>
const sum = await wasm.calculate(5, 3, "add");
console.log(sum);  // 8

// TypeScript knows the return type is Promise<{ displayName: string, status: string }>
const user = await wasm.formatUser("Alice", 30, true);
console.log(user.displayName);  // "Alice (30)"
console.log(user.status);       // "active"
```

### 3. Clean up when done

```typescript
// Terminate the Web Worker when you're done
wasm.terminate();
```

### 4. TypeScript catches your mistakes

```typescript
// Error: Argument of type 'number' is not assignable to parameter of type 'string'
await wasm.greet(42);

// Error: Expected 3 arguments, but got 2
await wasm.calculate(5, 3);

// Error: Property 'wrongField' does not exist
const user = await wasm.formatUser("Bob", 25, false);
console.log(user.wrongField);
```

## Complete Example

See the [example/src/app.ts](../example/src/app.ts) for a working TypeScript application that uses the generated class API.

```typescript
import { Main } from './generated/client';

async function main(): Promise<void> {
    // Initialize the WASM module in a Web Worker
    const wasm = await Main.init('./worker.js');

    // Call Go functions with full type safety
    const greeting = await wasm.greet("TypeScript");
    console.log(greeting);  // "Hello, TypeScript!"

    const result = await wasm.calculate(10, 5, "add");
    console.log(result);  // 15

    // Clean up when done
    wasm.terminate();
}

void main();
```

## Troubleshooting

### "Cannot find module './client'"

Make sure you've generated the TypeScript client:

```bash
gowasm-bindgen --output generated/client.ts --go-output go/bindings_gen.go go/main.go
```

This creates `generated/client.ts`, `generated/worker.js` (by default), and `go/bindings_gen.go` (Go bindings).

### Return type is `any` instead of a specific type

This shouldn't happen with the new source-based generation. gowasm-bindgen infers types directly from Go function signatures:

```go
// Go code - types are inferred from the signature
func Greet(name string) string {
    return "Hello, " + name + "!"
}
// → TypeScript: greet(name: string): Promise<string>
```

If you see `any`, the Go function might be using `interface{}`. Ask your Go teammate to use concrete types.

### Worker fails to load / "Failed to construct 'Worker'"

- Make sure `worker.js` and `example.wasm` are in the correct location relative to your HTML
- Check that your bundler (if using one) is configured to copy these files to your output directory
- Verify the worker URL path is correct (relative to your HTML page, not your TypeScript file)

### Want synchronous calls instead of async?

Use the `--sync` flag to generate a synchronous API that runs on the main thread:

```bash
gowasm-bindgen --output generated/client.ts --go-output go/bindings_gen.go --sync go/main.go
```

```typescript
// Sync mode - no await, no Web Worker
const wasm = await Main.init('./example.wasm');  // init is still async
const greeting = wasm.greet('World');  // but calls are sync
```

Note: Sync mode blocks the main thread, which can freeze your UI for long-running operations.

## Project Structure

A typical project using gowasm-bindgen looks like this:

```
your-project/
├── go/                   # All Go code
│   ├── main.go           # Go code with normal functions (your teammate writes this)
│   ├── main_test.go      # Optional unit tests
│   └── bindings_gen.go   # Generated Go WASM bindings (gitignored)
├── src/                  # TypeScript source
│   └── app.ts            # Your TypeScript code
├── public/               # Static assets
│   └── index.html        # Source HTML
├── generated/            # Generated TS/JS (gitignored)
│   ├── client.ts         # Generated TypeScript class
│   └── worker.js         # Generated Web Worker
└── dist/                 # Build output (served to browser)
    ├── index.html
    ├── app.js            # Bundled TypeScript
    ├── worker.js         # Web Worker (copied from generated/)
    └── example.wasm      # Compiled Go code
```

## Common Gotchas

### 1. Worker Mode Is Async (default)

By default, gowasm-bindgen generates an async Worker-based API:

```typescript
// ✅ Correct - await the Promise
const result = await wasm.greet("World");

// ❌ Wrong - forgot await, result is a Promise!
const result = wasm.greet("World");
console.log(result);  // Promise { <pending> }
```

**Want sync?** Use `--sync` flag for synchronous calls (but this blocks the main thread):

```bash
gowasm-bindgen --output generated/client.ts --go-output go/bindings_gen.go --sync go/main.go
```

```typescript
const wasm = await Main.init('./example.wasm');
const result = wasm.greet("World");  // No await - synchronous
```

### 2. Always Await init()

Module initialization is always async, even in sync mode:

```typescript
// ❌ Wrong - forgot await on init
const wasm = Main.init('./worker.js');
await wasm.greet("World");  // Error: wasm is a Promise!

// ✅ Correct - await init first
const wasm = await Main.init('./worker.js');
await wasm.greet("World");  // Now it works
```

### 3. Types Don't Validate Runtime Data

Generated types tell TypeScript what to expect, but they don't enforce it at runtime:

```typescript
const user = await wasm.formatUser("Alice", 30, true);
// TypeScript thinks: { displayName: string, status: string }

// But if the Go code changes to return { name, active } instead,
// TypeScript won't catch it! The generated types become stale.
```

**Solution:** Regenerate types when Go code changes, and keep tests in sync.

### 4. Memory Considerations

Each call to a WASM function copies data between JavaScript and Go:

```typescript
// ❌ Slow - copying large data on every call
for (const item of hugeArray) {
  await wasm.processItem(item);
}

// ✅ Better - batch if possible
await wasm.processItems(hugeArray.join(","));
```

### 5. Debugging WASM Functions

TypeScript debuggers can't step into WASM code. Use logging:

```typescript
// Log before/after the WASM call
console.log("Calling greet with:", name);
const result = await wasm.greet(name);
console.log("Result:", result);
```

In Go code, you can log to the browser console:
```go
js.Global().Get("console").Call("log", "Debug from Go:", value)
```

### 6. The `void` Operator Pattern

You'll see `void` in our examples:

```typescript
void main();
```

This is NOT "ignore the result"—it explicitly marks a Promise as intentionally not awaited. ESLint requires this to prevent accidental fire-and-forget bugs.

## TypeScript Configuration

The generated `client.ts` is just a TypeScript file you can import directly. No special tsconfig needed beyond standard module resolution.

## Next Steps

- Check out the [example/](../example/) directory for a complete working demo
- Run `make serve` in the example directory, then open http://localhost:8080
- Read [for-go-devs.md](./for-go-devs.md) if you want to understand how the Go side works
