# gowasm-bindgen for TypeScript Developers

You know TypeScript. You're curious about Go. Here's how to run Go code in your browser with full type safety.

## Why Go in the Browser?

- **Performance**: Go compiles to WebAssembly, running at near-native speed
- **Shared logic**: Use the same code on your backend and frontend
- **Type safety**: With gowasm-bindgen, your Go functions get proper TypeScript types

## What You Need to Know

Your Go teammate writes the WASM module and tests. You use the generated `.d.ts` file. That's it.

**The 4 files you care about:**

| File | What it is |
|------|------------|
| `example.wasm` | The compiled Go code (runs in the browser) |
| `wasm_exec.js` | Go's WASM runtime (loads the .wasm file) |
| `types.d.ts` | Generated TypeScript declarations (your function types) |
| `wasm_exec.d.ts` | Generated TypeScript declarations (Go runtime types) |

Both `.d.ts` files are generated by gowasm-bindgen.

## Using the Generated Types

### 1. Add types to tsconfig.json

```json
{
  "include": ["src/**/*", "types.d.ts", "wasm_exec.d.ts"]
}
```

### 2. Load the WASM module

```typescript
// Go class is typed via wasm_exec.d.ts - no 'any' needed!
const go = new Go();

const result = await WebAssembly.instantiateStreaming(
    fetch("./example.wasm"),
    go.importObject
);
void go.run(result.instance);
```

### 3. Call Go functions with full type checking

```typescript
// TypeScript knows: greet(name: string): string
const greeting = window.greet("World");
console.log(greeting);  // "Hello, World!"

// TypeScript knows: calculate(a: number, b: number, op: string): number
const sum = window.calculate(5, 3, "add");
console.log(sum);  // 8

// TypeScript knows the return type is { displayName: string, status: string }
const user = window.formatUser("Alice", 30, true);
console.log(user.displayName);  // "Alice (30)"
console.log(user.status);       // "active"
```

### 4. TypeScript catches your mistakes

```typescript
// Error: Argument of type 'number' is not assignable to parameter of type 'string'
window.greet(42);

// Error: Expected 3 arguments, but got 2
window.calculate(5, 3);

// Error: Property 'wrongField' does not exist
const user = window.formatUser("Bob", 25, false);
console.log(user.wrongField);
```

## Complete Example

See the [example/web/app.ts](../example/web/app.ts) for a working TypeScript application that uses generated types.

```typescript
// Types included via tsconfig.json - no triple-slash needed
async function initWasm(): Promise<void> {
    const go = new Go();

    const result = await WebAssembly.instantiateStreaming(
        fetch("example.wasm"),
        go.importObject
    );
    void go.run(result.instance);

    // Now you can call Go functions with type safety
    const greeting: string = window.greet("TypeScript");
    console.log(greeting);
}

void initWasm();
```

## Troubleshooting

### "Property 'greet' does not exist on type 'Window'"

You need to include the generated types. Add the `.d.ts` files to your `tsconfig.json`:

```json
{
  "include": ["src/**/*", "types.d.ts", "wasm_exec.d.ts"]
}
```

### "Cannot find name 'Go'"

Two things to check:

1. Make sure `wasm_exec.d.ts` is included in your `tsconfig.json` (see above)
2. Make sure `wasm_exec.js` is loaded before your code runs:

```html
<script src="wasm_exec.js"></script>
<script src="your-app.js"></script>
```

### Return type is `any` instead of a specific type

This means the Go tests don't specify how the return value is used. Ask your Go teammate to add type assertions in their tests:

```go
// Go test code - the .String() tells gowasm-bindgen the return type
result := greet(js.Null(), []js.Value{js.ValueOf("World")})
jsResult := result.(js.Value)
got := jsResult.String()  // <- This makes the return type 'string'
```

### WASM won't load / "failed to asynchronously prepare wasm"

- Make sure your server serves `.wasm` files with the correct MIME type: `application/wasm`
- Check the browser console for more specific errors
- Try using `WebAssembly.instantiate` instead of `instantiateStreaming` for debugging

## Project Structure

A typical project using gowasm-bindgen looks like this:

```
your-project/
├── wasm/
│   ├── main.go           # Go code (your teammate writes this)
│   └── main_test.go      # Tests (gowasm-bindgen reads this)
├── web/
│   ├── index.html        # Source HTML
│   └── app.ts            # Your TypeScript code
├── dist/                 # Build output (served to browser)
│   ├── index.html
│   ├── app.js            # Bundled TypeScript
│   ├── example.wasm      # Compiled Go code
│   └── wasm_exec.js      # Go's WASM runtime
├── types.d.ts            # Generated declarations (dev only)
├── wasm_exec.d.ts        # Go runtime declarations (dev only)
└── wasm_exec.js          # Go's WASM runtime (from TinyGo/Go)
```

## Common Gotchas

### 1. WASM Functions Are Synchronous

Go WASM functions return immediately—they're not async:

```typescript
// ✅ Correct - synchronous call
const result = window.greet("World");

// ❌ Wrong - greet() doesn't return a Promise!
const result = await window.greet("World");
```

### 2. Module Loading Is Async, Function Calls Are Not

```typescript
// ❌ Wrong - WASM isn't loaded yet!
const go = new Go();
WebAssembly.instantiateStreaming(fetch("app.wasm"), go.importObject);
window.greet("World");  // Error: greet is not defined

// ✅ Correct - wait for WASM to load first
const go = new Go();
const result = await WebAssembly.instantiateStreaming(fetch("app.wasm"), go.importObject);
void go.run(result.instance);
window.greet("World");  // Now it works
```

### 3. Types Don't Validate Runtime Data

Generated types tell TypeScript what to expect, but they don't enforce it at runtime:

```typescript
const user = window.formatUser("Alice", 30, true);
// TypeScript thinks: { displayName: string, status: string }

// But if the Go code changes to return { name, active } instead,
// TypeScript won't catch it! The generated types become stale.
```

**Solution:** Regenerate types when Go code changes, and keep tests in sync.

### 4. Memory Considerations

Each call to a WASM function copies data between JavaScript and Go:

```typescript
// ❌ Slow - copying large data on every call
for (const item of hugeArray) {
  window.processItem(item);
}

// ✅ Better - batch if possible
window.processItems(hugeArray.join(","));
```

### 5. Debugging WASM Functions

TypeScript debuggers can't step into WASM code. Use logging:

```typescript
// Log before/after the WASM call
console.log("Calling greet with:", name);
const result = window.greet(name);
console.log("Result:", result);
```

In Go code, you can log to the browser console:
```go
js.Global().Get("console").Call("log", "Debug from Go:", value)
```

### 6. The `void` Operator Pattern

You'll see `void` in our examples:

```typescript
void go.run(result.instance);
void initWasm();
```

This is NOT "ignore the result"—it explicitly marks a Promise as intentionally not awaited. ESLint requires this to prevent accidental fire-and-forget bugs.

## TypeScript Configuration

See [typescript-config.md](./typescript-config.md) for a detailed explanation of our strict tsconfig settings.

## Next Steps

- Check out the [example/](../example/) directory for a complete working demo
- Run `make serve` in the example directory, then open http://localhost:8080
- Read [for-go-devs.md](./for-go-devs.md) if you want to understand how the Go side works
