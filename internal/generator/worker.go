package generator

import (
	"fmt"
	"strings"

	"github.com/13rac1/gowasm-bindgen/internal/parser"
)

// GenerateWorker creates worker.js content that runs Go WASM in a Web Worker.
// The wasmPath parameter specifies the path to the WASM file (e.g., "module.wasm").
func GenerateWorker(wasmPath string) string {
	return `/**
 * Go WASM Web Worker
 * Generated by gowasm-bindgen
 *
 * This worker loads the Go WASM module and handles function calls
 * from the main thread via postMessage.
 */

// Load Go WASM runtime
importScripts('wasm_exec.js');

const go = new Go();
let wasmReady = false;

// Global for Go to invoke callbacks (fire-and-forget)
// Go calls this to relay callback invocations to the main thread
self.invokeCallback = function(callbackId, args) {
  self.postMessage({ type: 'invokeCallback', callbackId: callbackId, args: args });
};

// Initialize WASM
fetch('` + wasmPath + `')
  .then(response => WebAssembly.instantiateStreaming(response, go.importObject))
  .then(result => {
    go.run(result.instance);
    wasmReady = true;
    self.postMessage({ type: 'ready' });
  })
  .catch(error => {
    self.postMessage({ type: 'error', error: error.message });
  });

// Handle function calls from main thread
self.onmessage = (event) => {
  const { id, fn, args } = event.data;

  if (!wasmReady) {
    self.postMessage({ id, error: 'WASM not ready' });
    return;
  }

  try {
    const result = self[fn](...args);
    self.postMessage({ id, result });
  } catch (error) {
    self.postMessage({ id, error: error.message });
  }
};
`
}

// GenerateClient creates client.ts with a class-based API for worker mode.
func GenerateClient(parsed *parser.ParsedFile) string {
	className := toClassName(parsed.Package)

	var b strings.Builder

	b.WriteString(fmt.Sprintf(`// client.ts - Generated by gowasm-bindgen
// Package: %s

`, parsed.Package))

	// Generate named interfaces for struct return types
	for _, fn := range parsed.Functions {
		if iface := GenerateInterfaceForFunction(fn, parsed.Types); iface != "" {
			b.WriteString(iface)
			b.WriteString("\n\n")
		}
	}

	// Generate the class
	b.WriteString("export class ")
	b.WriteString(className)
	b.WriteString(" {\n")
	b.WriteString("  private worker: Worker;\n")
	b.WriteString("  private requestId = 0;\n")
	b.WriteString("  private pending = new Map<number, { resolve: (v: unknown) => void; reject: (e: Error) => void }>();\n")
	b.WriteString("  private nextCallbackId = 0;\n")
	b.WriteString("  private callbacks = new Map<number, (...args: unknown[]) => void>();\n\n")

	b.WriteString("  private constructor(worker: Worker) {\n")
	b.WriteString("    this.worker = worker;\n")
	b.WriteString("  }\n\n")

	// Static init method
	b.WriteString("  static async init(workerUrl: string): Promise<")
	b.WriteString(className)
	b.WriteString("> {\n")
	b.WriteString("    const worker = new Worker(workerUrl);\n")
	b.WriteString("    const instance = new ")
	b.WriteString(className)
	b.WriteString("(worker);\n\n")

	b.WriteString("    await new Promise<void>((resolve, reject) => {\n")
	b.WriteString("      worker.onmessage = (event) => {\n")
	b.WriteString("        const { type, id, result, error, callbackId, args } = event.data;\n")
	b.WriteString("        if (type === 'ready') {\n")
	b.WriteString("          resolve();\n")
	b.WriteString("          return;\n")
	b.WriteString("        }\n")
	b.WriteString("        // Handle callback invocations from Go\n")
	b.WriteString("        if (type === 'invokeCallback') {\n")
	b.WriteString("          const callback = instance.callbacks.get(callbackId);\n")
	b.WriteString("          if (callback) {\n")
	b.WriteString("            try { callback(...args); }\n")
	b.WriteString("            catch (e) { console.error('Callback error:', e); }\n")
	b.WriteString("          }\n")
	b.WriteString("          return;\n")
	b.WriteString("        }\n")
	b.WriteString("        const handler = instance.pending.get(id);\n")
	b.WriteString("        if (handler) {\n")
	b.WriteString("          instance.pending.delete(id);\n")
	b.WriteString("          if (error) {\n")
	b.WriteString("            handler.reject(new Error(error));\n")
	b.WriteString("          } else if (result && typeof result === 'object' && '")
	b.WriteString(ErrorFieldName)
	b.WriteString("' in result) {\n")
	b.WriteString("            handler.reject(new Error((result as { ")
	b.WriteString(ErrorFieldName)
	b.WriteString(": string }).")
	b.WriteString(ErrorFieldName)
	b.WriteString("));\n")
	b.WriteString("          } else {\n")
	b.WriteString("            handler.resolve(result);\n")
	b.WriteString("          }\n")
	b.WriteString("        }\n")
	b.WriteString("      };\n")
	b.WriteString("      worker.onerror = (e) => reject(new Error(e.message || 'Worker failed to load'));\n")
	b.WriteString("    });\n\n")

	b.WriteString("    return instance;\n")
	b.WriteString("  }\n\n")

	// Terminate method
	b.WriteString("  terminate(): void {\n")
	b.WriteString("    this.worker.terminate();\n")
	b.WriteString("  }\n\n")

	// Private call method
	b.WriteString("  private call<T>(fn: string, args: unknown[]): Promise<T> {\n")
	b.WriteString("    return new Promise((resolve, reject) => {\n")
	b.WriteString("      const id = ++this.requestId;\n")
	b.WriteString("      this.pending.set(id, { resolve: resolve as (v: unknown) => void, reject });\n")
	b.WriteString("      this.worker.postMessage({ id, fn, args });\n")
	b.WriteString("    });\n")
	b.WriteString("  }\n\n")

	// Private registerCallback method
	b.WriteString("  private registerCallback(fn: (...args: unknown[]) => void): number {\n")
	b.WriteString("    const id = ++this.nextCallbackId;\n")
	b.WriteString("    this.callbacks.set(id, fn);\n")
	b.WriteString("    return id;\n")
	b.WriteString("  }\n")

	// Instance methods
	for _, fn := range parsed.Functions {
		b.WriteString("\n")
		b.WriteString(GenerateWorkerClassMethod(fn))
	}

	b.WriteString("}\n")
	return b.String()
}

// GenerateWorkerClassMethod creates a single async instance method for worker mode.
func GenerateWorkerClassMethod(fn parser.GoFunction) string {
	var b strings.Builder

	// JSDoc if present
	if fn.Doc != "" {
		lines := strings.Split(fn.Doc, "\n")
		b.WriteString("  /**\n")
		for _, line := range lines {
			b.WriteString("   * ")
			b.WriteString(line)
			b.WriteString("\n")
		}
		b.WriteString("   */\n")
	}

	params := GenerateFunctionParams(fn.Params)
	returnType := determineReturnType(fn)
	funcName := lowerFirst(fn.Name)

	// Check if any parameters are callbacks
	var callbackParams []int
	for i, p := range fn.Params {
		if p.Type.Kind == parser.KindFunction {
			callbackParams = append(callbackParams, i)
		}
	}
	hasCallbacks := len(callbackParams) > 0

	b.WriteString("  ")
	b.WriteString(funcName)
	b.WriteString("(")
	b.WriteString(params)
	b.WriteString("): Promise<")
	b.WriteString(returnType)
	b.WriteString("> {\n")

	if hasCallbacks {
		// Register callbacks and get their IDs
		// Cast to unknown[] => void since registerCallback uses a generic signature
		for _, idx := range callbackParams {
			paramName := fn.Params[idx].Name
			b.WriteString(fmt.Sprintf("    const %sId = this.registerCallback(%s as (...args: unknown[]) => void);\n", paramName, paramName))
		}

		// Build the call with .finally() for cleanup
		b.WriteString("    return this.call<")
		b.WriteString(returnType)
		b.WriteString(">(\"")
		b.WriteString(funcName)
		b.WriteString("\", [")

		// Generate argument list, replacing callbacks with their IDs
		argNames := make([]string, len(fn.Params))
		for i, p := range fn.Params {
			if p.Type.Kind == parser.KindFunction {
				argNames[i] = p.Name + "Id"
			} else {
				argNames[i] = p.Name
			}
		}
		b.WriteString(strings.Join(argNames, ", "))

		b.WriteString("]).finally(() => {\n")

		// Clean up all registered callbacks
		for _, idx := range callbackParams {
			paramName := fn.Params[idx].Name
			b.WriteString(fmt.Sprintf("      this.callbacks.delete(%sId);\n", paramName))
		}

		b.WriteString("    });\n")
	} else {
		// No callbacks - simple call
		b.WriteString("    return this.call<")
		b.WriteString(returnType)
		b.WriteString(">(\"")
		b.WriteString(funcName)
		b.WriteString("\", [")

		// Generate argument list
		argNames := make([]string, len(fn.Params))
		for i, p := range fn.Params {
			argNames[i] = p.Name
		}
		b.WriteString(strings.Join(argNames, ", "))

		b.WriteString("]);\n")
	}

	b.WriteString("  }\n")

	return b.String()
}
