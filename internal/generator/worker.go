package generator

import (
	"fmt"
	"strings"

	"github.com/13rac1/gowasm-bindgen/internal/extractor"
)

// GenerateWorker creates worker.js content that runs Go WASM in a Web Worker.
func GenerateWorker() string {
	return `/**
 * Go WASM Web Worker
 * Generated by gowasm-bindgen
 *
 * This worker loads the Go WASM module and handles function calls
 * from the main thread via postMessage.
 */

// Load Go WASM runtime
importScripts('wasm_exec.js');

const go = new Go();
let wasmReady = false;

// Initialize WASM
fetch('example.wasm')
  .then(response => WebAssembly.instantiateStreaming(response, go.importObject))
  .then(result => {
    go.run(result.instance);
    wasmReady = true;
    self.postMessage({ type: 'ready' });
  })
  .catch(error => {
    self.postMessage({ type: 'error', error: error.message });
  });

// Handle function calls from main thread
self.onmessage = (event) => {
  const { id, fn, args } = event.data;

  if (!wasmReady) {
    self.postMessage({ id, error: 'WASM not ready' });
    return;
  }

  try {
    const result = self[fn](...args);
    self.postMessage({ id, result });
  } catch (error) {
    self.postMessage({ id, error: error.message });
  }
};
`
}

// GenerateClient creates client.ts with a class-based API for worker mode.
func GenerateClient(sigs []extractor.FunctionSignature, packageName string) string {
	className := toClassName(packageName)

	var b strings.Builder

	b.WriteString(fmt.Sprintf(`// client.ts - Generated by gowasm-bindgen
// Package: %s

`, packageName))

	// Generate named interfaces for object return types
	for _, sig := range sigs {
		if iface := GenerateExportedInterface(sig); iface != "" {
			b.WriteString(iface)
			b.WriteString("\n\n")
		}
	}

	// Generate the class
	b.WriteString("export class ")
	b.WriteString(className)
	b.WriteString(" {\n")
	b.WriteString("  private worker: Worker;\n")
	b.WriteString("  private requestId = 0;\n")
	b.WriteString("  private pending = new Map<number, { resolve: (v: unknown) => void; reject: (e: Error) => void }>();\n\n")

	b.WriteString("  private constructor(worker: Worker) {\n")
	b.WriteString("    this.worker = worker;\n")
	b.WriteString("  }\n\n")

	// Static init method
	b.WriteString("  static async init(workerUrl: string): Promise<")
	b.WriteString(className)
	b.WriteString("> {\n")
	b.WriteString("    const worker = new Worker(workerUrl);\n")
	b.WriteString("    const instance = new ")
	b.WriteString(className)
	b.WriteString("(worker);\n\n")

	b.WriteString("    await new Promise<void>((resolve, reject) => {\n")
	b.WriteString("      worker.onmessage = (event) => {\n")
	b.WriteString("        const { type, id, result, error } = event.data;\n")
	b.WriteString("        if (type === 'ready') {\n")
	b.WriteString("          resolve();\n")
	b.WriteString("          return;\n")
	b.WriteString("        }\n")
	b.WriteString("        const handler = instance.pending.get(id);\n")
	b.WriteString("        if (handler) {\n")
	b.WriteString("          instance.pending.delete(id);\n")
	b.WriteString("          error ? handler.reject(new Error(error)) : handler.resolve(result);\n")
	b.WriteString("        }\n")
	b.WriteString("      };\n")
	b.WriteString("      worker.onerror = reject;\n")
	b.WriteString("    });\n\n")

	b.WriteString("    return instance;\n")
	b.WriteString("  }\n\n")

	// Terminate method
	b.WriteString("  terminate(): void {\n")
	b.WriteString("    this.worker.terminate();\n")
	b.WriteString("  }\n\n")

	// Private call method
	b.WriteString("  private call<T>(fn: string, args: unknown[]): Promise<T> {\n")
	b.WriteString("    return new Promise((resolve, reject) => {\n")
	b.WriteString("      const id = ++this.requestId;\n")
	b.WriteString("      this.pending.set(id, { resolve: resolve as (v: unknown) => void, reject });\n")
	b.WriteString("      this.worker.postMessage({ id, fn, args });\n")
	b.WriteString("    });\n")
	b.WriteString("  }\n")

	// Instance methods
	for _, sig := range sigs {
		b.WriteString("\n")
		b.WriteString(GenerateWorkerClassMethod(sig))
	}

	b.WriteString("}\n")
	return b.String()
}

// GenerateWorkerClassMethod creates a single async instance method for worker mode.
func GenerateWorkerClassMethod(sig extractor.FunctionSignature) string {
	var b strings.Builder

	// JSDoc if present
	jsDoc := GenerateJSDoc(sig)
	if jsDoc != "" {
		// Indent JSDoc for class method
		lines := strings.Split(jsDoc, "\n")
		for _, line := range lines {
			b.WriteString("  ")
			b.WriteString(line)
			b.WriteString("\n")
		}
	}

	params := GenerateParams(sig.Params)

	// Use named interface for object returns, otherwise use the type directly
	var returnType string
	if len(sig.Returns.Fields) > 0 {
		returnType = InterfaceName(sig.Name)
	} else {
		returnType = sig.Returns.Type
	}

	b.WriteString("  ")
	b.WriteString(sig.Name)
	b.WriteString("(")
	b.WriteString(params)
	b.WriteString("): Promise<")
	b.WriteString(returnType)
	b.WriteString("> {\n")
	b.WriteString("    return this.call<")
	b.WriteString(returnType)
	b.WriteString(">(\"")
	b.WriteString(sig.Name)
	b.WriteString("\", [")

	// Generate argument list
	argNames := make([]string, len(sig.Params))
	for i, p := range sig.Params {
		argNames[i] = p.Name
	}
	b.WriteString(strings.Join(argNames, ", "))

	b.WriteString("]);\n")
	b.WriteString("  }\n")

	return b.String()
}
