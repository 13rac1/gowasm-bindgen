package generator

import (
	"fmt"
	"strings"

	"github.com/13rac1/gowasm-bindgen/internal/parser"
)

// GenerateWorker creates worker.js content that runs Go WASM in a Web Worker.
func GenerateWorker() string {
	return `/**
 * Go WASM Web Worker
 * Generated by gowasm-bindgen
 *
 * This worker loads the Go WASM module and handles function calls
 * from the main thread via postMessage.
 */

// Load Go WASM runtime
importScripts('wasm_exec.js');

const go = new Go();
let wasmReady = false;

// Initialize WASM
fetch('example.wasm')
  .then(response => WebAssembly.instantiateStreaming(response, go.importObject))
  .then(result => {
    go.run(result.instance);
    wasmReady = true;
    self.postMessage({ type: 'ready' });
  })
  .catch(error => {
    self.postMessage({ type: 'error', error: error.message });
  });

// Handle function calls from main thread
self.onmessage = (event) => {
  const { id, fn, args } = event.data;

  if (!wasmReady) {
    self.postMessage({ id, error: 'WASM not ready' });
    return;
  }

  try {
    const result = self[fn](...args);
    self.postMessage({ id, result });
  } catch (error) {
    self.postMessage({ id, error: error.message });
  }
};
`
}

// GenerateClient creates client.ts with a class-based API for worker mode.
func GenerateClient(parsed *parser.ParsedFile) string {
	className := toClassName(parsed.Package)

	var b strings.Builder

	b.WriteString(fmt.Sprintf(`// client.ts - Generated by gowasm-bindgen
// Package: %s

`, parsed.Package))

	// Generate named interfaces for struct return types
	for _, fn := range parsed.Functions {
		if iface := GenerateInterfaceForFunction(fn, parsed.Types); iface != "" {
			b.WriteString(iface)
			b.WriteString("\n\n")
		}
	}

	// Generate the class
	b.WriteString("export class ")
	b.WriteString(className)
	b.WriteString(" {\n")
	b.WriteString("  private worker: Worker;\n")
	b.WriteString("  private requestId = 0;\n")
	b.WriteString("  private pending = new Map<number, { resolve: (v: unknown) => void; reject: (e: Error) => void }>();\n\n")

	b.WriteString("  private constructor(worker: Worker) {\n")
	b.WriteString("    this.worker = worker;\n")
	b.WriteString("  }\n\n")

	// Static init method
	b.WriteString("  static async init(workerUrl: string): Promise<")
	b.WriteString(className)
	b.WriteString("> {\n")
	b.WriteString("    const worker = new Worker(workerUrl);\n")
	b.WriteString("    const instance = new ")
	b.WriteString(className)
	b.WriteString("(worker);\n\n")

	b.WriteString("    await new Promise<void>((resolve, reject) => {\n")
	b.WriteString("      worker.onmessage = (event) => {\n")
	b.WriteString("        const { type, id, result, error } = event.data;\n")
	b.WriteString("        if (type === 'ready') {\n")
	b.WriteString("          resolve();\n")
	b.WriteString("          return;\n")
	b.WriteString("        }\n")
	b.WriteString("        const handler = instance.pending.get(id);\n")
	b.WriteString("        if (handler) {\n")
	b.WriteString("          instance.pending.delete(id);\n")
	b.WriteString("          error ? handler.reject(new Error(error)) : handler.resolve(result);\n")
	b.WriteString("        }\n")
	b.WriteString("      };\n")
	b.WriteString("      worker.onerror = (e) => reject(new Error(e.message || 'Worker failed to load'));\n")
	b.WriteString("    });\n\n")

	b.WriteString("    return instance;\n")
	b.WriteString("  }\n\n")

	// Terminate method
	b.WriteString("  terminate(): void {\n")
	b.WriteString("    this.worker.terminate();\n")
	b.WriteString("  }\n\n")

	// Private call method
	b.WriteString("  private call<T>(fn: string, args: unknown[]): Promise<T> {\n")
	b.WriteString("    return new Promise((resolve, reject) => {\n")
	b.WriteString("      const id = ++this.requestId;\n")
	b.WriteString("      this.pending.set(id, { resolve: resolve as (v: unknown) => void, reject });\n")
	b.WriteString("      this.worker.postMessage({ id, fn, args });\n")
	b.WriteString("    });\n")
	b.WriteString("  }\n")

	// Instance methods
	for _, fn := range parsed.Functions {
		b.WriteString("\n")
		b.WriteString(GenerateWorkerClassMethod(fn))
	}

	b.WriteString("}\n")
	return b.String()
}

// GenerateWorkerClassMethod creates a single async instance method for worker mode.
func GenerateWorkerClassMethod(fn parser.GoFunction) string {
	var b strings.Builder

	// JSDoc if present
	if fn.Doc != "" {
		lines := strings.Split(fn.Doc, "\n")
		b.WriteString("  /**\n")
		for _, line := range lines {
			b.WriteString("   * ")
			b.WriteString(line)
			b.WriteString("\n")
		}
		b.WriteString("   */\n")
	}

	params := GenerateFunctionParams(fn.Params)

	// Determine return type
	var returnType string
	hasError := len(fn.Returns) > 0 && fn.Returns[len(fn.Returns)-1].IsError
	hasNonErrorReturn := len(fn.Returns) > 0 && (!hasError || len(fn.Returns) > 1)

	if hasNonErrorReturn {
		returnType = parser.GoTypeToTS(fn.Returns[0])
		// For struct returns, use interface name
		if fn.Returns[0].Kind == parser.KindStruct {
			returnType = InterfaceName(fn.Name)
		}
	} else {
		returnType = "void"
	}

	funcName := lowerFirst(fn.Name)

	b.WriteString("  ")
	b.WriteString(funcName)
	b.WriteString("(")
	b.WriteString(params)
	b.WriteString("): Promise<")
	b.WriteString(returnType)
	b.WriteString("> {\n")
	b.WriteString("    return this.call<")
	b.WriteString(returnType)
	b.WriteString(">(\"")
	b.WriteString(funcName)
	b.WriteString("\", [")

	// Generate argument list
	argNames := make([]string, len(fn.Params))
	for i, p := range fn.Params {
		argNames[i] = p.Name
	}
	b.WriteString(strings.Join(argNames, ", "))

	b.WriteString("]);\n")
	b.WriteString("  }\n")

	return b.String()
}
