package generator

import (
	"strings"

	"github.com/13rac1/gowasm-bindgen/internal/extractor"
)

// GenerateWorker creates worker.js content that runs Go WASM in a Web Worker.
func GenerateWorker() string {
	return `/**
 * Go WASM Web Worker
 * Generated by gowasm-bindgen --worker
 *
 * This worker loads the Go WASM module and handles function calls
 * from the main thread via postMessage.
 */

// Load Go WASM runtime
importScripts('wasm_exec.js');

const go = new Go();
let wasmReady = false;

// Initialize WASM
fetch('example.wasm')
  .then(response => WebAssembly.instantiateStreaming(response, go.importObject))
  .then(result => {
    go.run(result.instance);
    wasmReady = true;
    self.postMessage({ type: 'ready' });
  })
  .catch(error => {
    self.postMessage({ type: 'error', error: error.message });
  });

// Handle function calls from main thread
self.onmessage = (event) => {
  const { id, fn, args } = event.data;

  if (!wasmReady) {
    self.postMessage({ id, error: 'WASM not ready' });
    return;
  }

  try {
    const result = self[fn](...args);
    self.postMessage({ id, result });
  } catch (error) {
    self.postMessage({ id, error: error.message });
  }
};
`
}

// GenerateClient creates client.ts content with typed function wrappers.
func GenerateClient(sigs []extractor.FunctionSignature) string {
	var b strings.Builder

	b.WriteString(`/**
 * Typed Web Worker client for Go WASM
 * Generated by gowasm-bindgen --worker
 *
 * Usage:
 *   import { init, greet } from './client';
 *   await init('./worker.js');
 *   const result = await greet('World');
 */

let worker: Worker;
let requestId = 0;
const pending = new Map<number, { resolve: (value: unknown) => void; reject: (error: Error) => void }>();
let readyPromise: Promise<void>;
let readyResolve: () => void;
let readyReject: (error: Error) => void;

/**
 * Initialize the Web Worker and load the WASM module.
 * Must be called before any other functions.
 */
export function init(workerUrl: string): Promise<void> {
  worker = new Worker(workerUrl);

  readyPromise = new Promise<void>((resolve, reject) => {
    readyResolve = resolve;
    readyReject = reject;
  });

  worker.onmessage = (event: MessageEvent): void => {
    const data = event.data as { type?: string; id?: number; result?: unknown; error?: string };

    if (data.type === 'ready') {
      readyResolve();
      return;
    }

    if (data.type === 'error') {
      readyReject(new Error(data.error ?? 'Unknown error'));
      return;
    }

    if (data.id !== undefined) {
      const handler = pending.get(data.id);
      if (handler) {
        pending.delete(data.id);
        if (data.error) {
          handler.reject(new Error(data.error));
        } else {
          handler.resolve(data.result);
        }
      }
    }
  };

  worker.onerror = (event: ErrorEvent): void => {
    readyReject(new Error(event.message));
  };

  return readyPromise;
}

/**
 * Terminate the Web Worker and release resources.
 */
export function terminate(): void {
  if (worker) {
    worker.terminate();
  }
}

function call<T>(fn: string, args: unknown[]): Promise<T> {
  return readyPromise.then(() => new Promise<T>((resolve, reject) => {
    const id = ++requestId;
    pending.set(id, {
      resolve: resolve as (value: unknown) => void,
      reject,
    });
    worker.postMessage({ id, fn, args });
  }));
}

`)

	// Generate named interfaces for object return types
	for _, sig := range sigs {
		if iface := GenerateExportedInterface(sig); iface != "" {
			b.WriteString(iface)
			b.WriteString("\n\n")
		}
	}

	// Generate function wrappers
	for _, sig := range sigs {
		b.WriteString(GenerateClientFunction(sig))
		b.WriteString("\n")
	}

	return b.String()
}

// GenerateClientFunction creates a typed async function wrapper.
func GenerateClientFunction(sig extractor.FunctionSignature) string {
	var b strings.Builder

	jsDoc := GenerateJSDoc(sig)
	if jsDoc != "" {
		b.WriteString(jsDoc)
		b.WriteString("\n")
	}

	params := GenerateParams(sig.Params)

	// Use named interface for object returns, otherwise use the type directly
	var returnType string
	if len(sig.Returns.Fields) > 0 {
		returnType = InterfaceName(sig.Name)
	} else {
		returnType = sig.Returns.Type
	}

	b.WriteString("export function ")
	b.WriteString(sig.Name)
	b.WriteString("(")
	b.WriteString(params)
	b.WriteString("): Promise<")
	b.WriteString(returnType)
	b.WriteString("> {\n")
	b.WriteString("  return call<")
	b.WriteString(returnType)
	b.WriteString(">(\"")
	b.WriteString(sig.Name)
	b.WriteString("\", [")

	// Generate argument list
	argNames := make([]string, len(sig.Params))
	for i, p := range sig.Params {
		argNames[i] = p.Name
	}
	b.WriteString(strings.Join(argNames, ", "))

	b.WriteString("]);\n")
	b.WriteString("}\n")

	return b.String()
}

// GenerateExportedInterface creates an exported interface for object return types.
func GenerateExportedInterface(sig extractor.FunctionSignature) string {
	if len(sig.Returns.Fields) == 0 {
		return ""
	}

	var b strings.Builder
	b.WriteString("export interface ")
	b.WriteString(InterfaceName(sig.Name))
	b.WriteString(" {\n")

	for _, field := range sig.Returns.Fields {
		b.WriteString("  ")
		b.WriteString(field.Name)
		b.WriteString(": ")
		b.WriteString(field.Type)
		b.WriteString(";\n")
	}

	b.WriteString("}")
	return b.String()
}
