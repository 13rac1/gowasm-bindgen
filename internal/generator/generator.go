package generator

import (
	"fmt"
	"strings"

	"github.com/13rac1/gowasm-bindgen/internal/parser"
)

// Generate creates TypeScript class-based client for sync mode.
// This generates a class that wraps globalThis function calls.
func Generate(parsed *parser.ParsedFile) string {
	className := toClassName(parsed.Package)

	var b strings.Builder
	b.WriteString(GenerateHeader(parsed.Package))
	b.WriteString("\n\n")

	// Generate named interfaces for struct return types
	for _, fn := range parsed.Functions {
		if iface := GenerateInterfaceForFunction(fn, parsed.Types); iface != "" {
			b.WriteString(iface)
			b.WriteString("\n\n")
		}
	}

	// Generate the class
	b.WriteString(GenerateClass(parsed.Functions, className))

	return b.String()
}

// GenerateHeader creates the file header comment.
func GenerateHeader(packageName string) string {
	return fmt.Sprintf(`// client.ts - Generated by gowasm-bindgen --sync
// Package: %s`, packageName)
}

// GenerateClass creates the TypeScript class with sync methods.
func GenerateClass(functions []parser.GoFunction, className string) string {
	var b strings.Builder

	b.WriteString("export class ")
	b.WriteString(className)
	b.WriteString(" {\n")
	b.WriteString("  private constructor() {}\n\n")

	// Static init method
	b.WriteString("  static async init(wasmUrl: string): Promise<")
	b.WriteString(className)
	b.WriteString("> {\n")
	b.WriteString("    const go = new Go();\n")
	b.WriteString("    const result = await WebAssembly.instantiateStreaming(fetch(wasmUrl), go.importObject);\n")
	b.WriteString("    void go.run(result.instance);\n")
	b.WriteString("    return new ")
	b.WriteString(className)
	b.WriteString("();\n")
	b.WriteString("  }\n")

	// Instance methods
	for _, fn := range functions {
		b.WriteString("\n")
		b.WriteString(GenerateClassMethod(fn))
	}

	b.WriteString("}\n")
	return b.String()
}

// GenerateClassMethod creates a single instance method that calls globalThis.
func GenerateClassMethod(fn parser.GoFunction) string {
	var b strings.Builder

	// JSDoc if present
	if fn.Doc != "" {
		lines := strings.Split(fn.Doc, "\n")
		b.WriteString("  /**\n")
		for _, line := range lines {
			b.WriteString("   * ")
			b.WriteString(line)
			b.WriteString("\n")
		}
		b.WriteString("   */\n")
	}

	params := GenerateFunctionParams(fn.Params)

	// Determine return type
	var returnType string
	hasError := len(fn.Returns) > 0 && fn.Returns[len(fn.Returns)-1].IsError
	hasNonErrorReturn := len(fn.Returns) > 0 && (!hasError || len(fn.Returns) > 1)

	if hasNonErrorReturn {
		returnType = parser.GoTypeToTS(fn.Returns[0])
		// For struct returns, use interface name
		if fn.Returns[0].Kind == parser.KindStruct {
			returnType = InterfaceName(fn.Name)
		}
	} else {
		returnType = "void"
	}

	funcName := lowerFirst(fn.Name)

	b.WriteString("  ")
	b.WriteString(funcName)
	b.WriteString("(")
	b.WriteString(params)
	b.WriteString("): ")
	b.WriteString(returnType)
	b.WriteString(" {\n")
	b.WriteString("    return (globalThis as any).")
	b.WriteString(funcName)
	b.WriteString("(")

	// Pass through parameters
	argNames := make([]string, len(fn.Params))
	for i, p := range fn.Params {
		argNames[i] = p.Name
	}
	b.WriteString(strings.Join(argNames, ", "))

	b.WriteString(");\n")
	b.WriteString("  }\n")

	return b.String()
}

// GenerateFunctionParams formats the parameter list as TypeScript.
func GenerateFunctionParams(params []parser.GoParameter) string {
	if len(params) == 0 {
		return ""
	}

	parts := make([]string, len(params))
	for i, p := range params {
		parts[i] = fmt.Sprintf("%s: %s", p.Name, parser.GoTypeToTS(p.Type))
	}
	return strings.Join(parts, ", ")
}

// GenerateInterfaceForFunction creates an exported interface if the function returns a struct.
// Returns empty string if the function doesn't return a struct type.
func GenerateInterfaceForFunction(fn parser.GoFunction, types map[string]*parser.GoType) string {
	if len(fn.Returns) == 0 {
		return ""
	}

	// Get the non-error return type
	hasError := fn.Returns[len(fn.Returns)-1].IsError
	if !hasError || len(fn.Returns) > 1 {
		returnType := fn.Returns[0]
		if returnType.Kind == parser.KindStruct {
			return generateStructInterface(InterfaceName(fn.Name), returnType)
		}
	}

	return ""
}

// generateStructInterface creates an interface from a struct type
func generateStructInterface(name string, structType parser.GoType) string {
	var b strings.Builder
	b.WriteString("export interface ")
	b.WriteString(name)
	b.WriteString(" {\n")

	for _, field := range structType.Fields {
		fieldName := field.JSONTag
		if fieldName == "" {
			// Use lowercase first letter
			fieldName = strings.ToLower(field.Name[:1]) + field.Name[1:]
		}

		b.WriteString("  ")
		b.WriteString(fieldName)
		b.WriteString(": ")
		b.WriteString(parser.GoTypeToTS(field.Type))
		b.WriteString(";\n")
	}

	b.WriteString("}")
	return b.String()
}

// InterfaceName converts a function name to a result interface name.
// e.g., "formatUser" -> "FormatUserResult", "getInfo" -> "GetInfoResult"
func InterfaceName(funcName string) string {
	if funcName == "" {
		return "Result"
	}
	// Capitalize first letter and append "Result"
	return strings.ToUpper(funcName[:1]) + funcName[1:] + "Result"
}

// toClassName converts a Go package name to a TypeScript class name.
// e.g., "wasm" -> "Wasm", "calculator" -> "Calculator"
func toClassName(packageName string) string {
	if packageName == "" {
		return "Wasm"
	}
	return strings.ToUpper(packageName[:1]) + packageName[1:]
}
