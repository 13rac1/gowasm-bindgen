package generator

import (
	"fmt"
	"strings"

	"github.com/13rac1/go-wasm-ts-gen/internal/extractor"
)

// Generate creates TypeScript declaration content from function signatures.
func Generate(sigs []extractor.FunctionSignature) string {
	if len(sigs) == 0 {
		return GenerateHeader() + "\nexport {};\n"
	}

	var b strings.Builder
	b.WriteString(GenerateHeader())
	b.WriteString("\n")

	for _, sig := range sigs {
		b.WriteString(GenerateFunction(sig))
		b.WriteString("\n")
	}

	b.WriteString("export {};\n")
	return b.String()
}

// GenerateHeader creates the file header comment.
func GenerateHeader() string {
	return `/**
 * Auto-generated TypeScript declarations for Go WASM exports
 * Generated by go-wasm-ts-gen
 */`
}

// GenerateFunction creates TypeScript declaration for a single function.
func GenerateFunction(sig extractor.FunctionSignature) string {
	var b strings.Builder

	jsDoc := GenerateJSDoc(sig)
	if jsDoc != "" {
		b.WriteString(jsDoc)
		b.WriteString("\n")
	}

	b.WriteString("declare global {\n")
	b.WriteString("  interface Window {\n")
	b.WriteString("    ")
	b.WriteString(sig.Name)
	b.WriteString("(")
	b.WriteString(GenerateParams(sig.Params))
	b.WriteString("): ")
	b.WriteString(GenerateReturnType(sig.Returns))
	b.WriteString(";\n")
	b.WriteString("  }\n")
	b.WriteString("}")

	return b.String()
}

// GenerateJSDoc creates JSDoc comment block with description and examples.
func GenerateJSDoc(sig extractor.FunctionSignature) string {
	if sig.Doc == "" && len(sig.Examples) == 0 {
		return ""
	}

	var b strings.Builder
	b.WriteString("/**")

	if sig.Doc != "" {
		b.WriteString("\n * ")
		b.WriteString(sig.Doc)
	}

	if len(sig.Examples) > 0 {
		if sig.Doc != "" {
			b.WriteString("\n *")
		}
		for _, ex := range sig.Examples {
			b.WriteString("\n * @example\n")
			b.WriteString(FormatExample(sig, ex))
		}
	}

	b.WriteString("\n */")
	return b.String()
}

// GenerateParams formats the parameter list as TypeScript.
func GenerateParams(params []extractor.Parameter) string {
	if len(params) == 0 {
		return ""
	}

	parts := make([]string, len(params))
	for i, p := range params {
		parts[i] = fmt.Sprintf("%s: %s", p.Name, p.Type)
	}
	return strings.Join(parts, ", ")
}

// GenerateReturnType formats the return type as TypeScript.
func GenerateReturnType(ret extractor.ReturnType) string {
	if ret.Type != "" && len(ret.Fields) == 0 {
		return ret.Type
	}

	if len(ret.Fields) == 0 {
		return "void"
	}

	if ret.IsUnion {
		return generateUnionType(ret.Fields)
	}

	return generateObjectType(ret.Fields)
}

// generateObjectType creates an object type literal from fields.
func generateObjectType(fields []extractor.Field) string {
	if len(fields) == 0 {
		return "{}"
	}

	parts := make([]string, len(fields))
	for i, f := range fields {
		parts[i] = fmt.Sprintf("%s: %s", f.Name, f.Type)
	}
	return "{" + strings.Join(parts, ", ") + "}"
}

// generateUnionType creates a union type from fields.
func generateUnionType(fields []extractor.Field) string {
	if len(fields) == 0 {
		return "void"
	}

	parts := make([]string, len(fields))
	for i, f := range fields {
		parts[i] = fmt.Sprintf("{%s: %s}", f.Name, f.Type)
	}
	return strings.Join(parts, " | ")
}

// FormatExample formats a single example for JSDoc.
func FormatExample(sig extractor.FunctionSignature, ex extractor.Example) string {
	var b strings.Builder

	if ex.Name != "" {
		b.WriteString(" * // ")
		b.WriteString(ex.Name)
		b.WriteString("\n")
	}

	b.WriteString(" * ")
	b.WriteString(sig.Name)
	b.WriteString("(")
	b.WriteString(strings.Join(ex.Args, ", "))
	b.WriteString(")")

	return b.String()
}
