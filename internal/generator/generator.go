package generator

import (
	"fmt"
	"strings"

	"github.com/13rac1/gowasm-bindgen/internal/extractor"
)

// Generate creates TypeScript class-based client for sync mode.
// This generates a class that wraps globalThis function calls.
func Generate(sigs []extractor.FunctionSignature, packageName string) string {
	className := toClassName(packageName)

	var b strings.Builder
	b.WriteString(GenerateHeader(packageName))
	b.WriteString("\n\n")

	// Generate named interfaces for object return types
	for _, sig := range sigs {
		if iface := GenerateExportedInterface(sig); iface != "" {
			b.WriteString(iface)
			b.WriteString("\n\n")
		}
	}

	// Generate the class
	b.WriteString(GenerateClass(sigs, className))

	return b.String()
}

// GenerateHeader creates the file header comment.
func GenerateHeader(packageName string) string {
	return fmt.Sprintf(`// client.ts - Generated by gowasm-bindgen --sync
// Package: %s`, packageName)
}

// GenerateClass creates the TypeScript class with sync methods.
func GenerateClass(sigs []extractor.FunctionSignature, className string) string {
	var b strings.Builder

	b.WriteString("export class ")
	b.WriteString(className)
	b.WriteString(" {\n")
	b.WriteString("  private constructor() {}\n\n")

	// Static init method
	b.WriteString("  static async init(wasmUrl: string): Promise<")
	b.WriteString(className)
	b.WriteString("> {\n")
	b.WriteString("    const go = new Go();\n")
	b.WriteString("    const result = await WebAssembly.instantiateStreaming(fetch(wasmUrl), go.importObject);\n")
	b.WriteString("    void go.run(result.instance);\n")
	b.WriteString("    return new ")
	b.WriteString(className)
	b.WriteString("();\n")
	b.WriteString("  }\n")

	// Instance methods
	for _, sig := range sigs {
		b.WriteString("\n")
		b.WriteString(GenerateClassMethod(sig))
	}

	b.WriteString("}\n")
	return b.String()
}

// GenerateClassMethod creates a single instance method that calls globalThis.
func GenerateClassMethod(sig extractor.FunctionSignature) string {
	var b strings.Builder

	// JSDoc if present
	jsDoc := GenerateJSDoc(sig)
	if jsDoc != "" {
		// Indent JSDoc for class method
		lines := strings.Split(jsDoc, "\n")
		for _, line := range lines {
			b.WriteString("  ")
			b.WriteString(line)
			b.WriteString("\n")
		}
	}

	params := GenerateParams(sig.Params)

	// Use named interface for object returns, otherwise use the type directly
	var returnType string
	if len(sig.Returns.Fields) > 0 {
		returnType = InterfaceName(sig.Name)
	} else {
		returnType = sig.Returns.Type
	}

	b.WriteString("  ")
	b.WriteString(sig.Name)
	b.WriteString("(")
	b.WriteString(params)
	b.WriteString("): ")
	b.WriteString(returnType)
	b.WriteString(" {\n")
	b.WriteString("    return (globalThis as any).")
	b.WriteString(sig.Name)
	b.WriteString("(")

	// Pass through parameters
	argNames := make([]string, len(sig.Params))
	for i, p := range sig.Params {
		argNames[i] = p.Name
	}
	b.WriteString(strings.Join(argNames, ", "))

	b.WriteString(");\n")
	b.WriteString("  }\n")

	return b.String()
}

// GenerateJSDoc creates JSDoc comment block with description and examples.
func GenerateJSDoc(sig extractor.FunctionSignature) string {
	if sig.Doc == "" && len(sig.Examples) == 0 {
		return ""
	}

	var b strings.Builder
	b.WriteString("/**")

	if sig.Doc != "" {
		b.WriteString("\n * ")
		b.WriteString(sig.Doc)
	}

	if len(sig.Examples) > 0 {
		if sig.Doc != "" {
			b.WriteString("\n *")
		}
		for _, ex := range sig.Examples {
			b.WriteString("\n * @example\n")
			b.WriteString(FormatExample(sig, ex))
		}
	}

	b.WriteString("\n */")
	return b.String()
}

// GenerateParams formats the parameter list as TypeScript.
func GenerateParams(params []extractor.Parameter) string {
	if len(params) == 0 {
		return ""
	}

	parts := make([]string, len(params))
	for i, p := range params {
		parts[i] = fmt.Sprintf("%s: %s", p.Name, p.Type)
	}
	return strings.Join(parts, ", ")
}

// FormatExample formats a single example for JSDoc.
func FormatExample(sig extractor.FunctionSignature, ex extractor.Example) string {
	var b strings.Builder

	if ex.Name != "" {
		b.WriteString(" * // ")
		b.WriteString(ex.Name)
		b.WriteString("\n")
	}

	b.WriteString(" * ")
	b.WriteString(sig.Name)
	b.WriteString("(")
	b.WriteString(strings.Join(ex.Args, ", "))
	b.WriteString(")")

	return b.String()
}

// GenerateExportedInterface creates an exported interface for object return types.
// Returns empty string if the function doesn't return an object type.
func GenerateExportedInterface(sig extractor.FunctionSignature) string {
	if len(sig.Returns.Fields) == 0 {
		return ""
	}

	var b strings.Builder
	b.WriteString("export interface ")
	b.WriteString(InterfaceName(sig.Name))
	b.WriteString(" {\n")

	for _, field := range sig.Returns.Fields {
		b.WriteString("  ")
		b.WriteString(field.Name)
		b.WriteString(": ")
		b.WriteString(field.Type)
		b.WriteString(";\n")
	}

	b.WriteString("}")
	return b.String()
}

// InterfaceName converts a function name to a result interface name.
// e.g., "formatUser" -> "FormatUserResult", "getInfo" -> "GetInfoResult"
func InterfaceName(funcName string) string {
	if funcName == "" {
		return "Result"
	}
	// Capitalize first letter and append "Result"
	return strings.ToUpper(funcName[:1]) + funcName[1:] + "Result"
}

// toClassName converts a Go package name to a TypeScript class name.
// e.g., "wasm" -> "Wasm", "calculator" -> "Calculator"
func toClassName(packageName string) string {
	if packageName == "" {
		return "Wasm"
	}
	return strings.ToUpper(packageName[:1]) + packageName[1:]
}
