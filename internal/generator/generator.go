package generator

import (
	"fmt"
	"strings"

	"github.com/13rac1/gowasm-bindgen/internal/extractor"
)

// Generate creates TypeScript declaration content from function signatures.
func Generate(sigs []extractor.FunctionSignature) string {
	if len(sigs) == 0 {
		return GenerateHeader() + "\nexport {};\n"
	}

	var b strings.Builder
	b.WriteString(GenerateHeader())
	b.WriteString("\n")

	// First, generate named interfaces for object return types
	for _, sig := range sigs {
		if iface := GenerateInterface(sig); iface != "" {
			b.WriteString(iface)
			b.WriteString("\n")
		}
	}

	// Then generate function declarations
	for _, sig := range sigs {
		b.WriteString(GenerateFunction(sig))
		b.WriteString("\n")
	}

	b.WriteString("export {};\n")
	return b.String()
}

// GenerateHeader creates the file header comment.
func GenerateHeader() string {
	return `/**
 * Auto-generated TypeScript declarations for Go WASM exports
 * Generated by gowasm-bindgen
 */`
}

// GenerateFunction creates TypeScript declaration for a single function.
// Generates both Window interface extension (for browsers) and var declaration (for Node.js/globalThis).
func GenerateFunction(sig extractor.FunctionSignature) string {
	var b strings.Builder

	jsDoc := GenerateJSDoc(sig)
	if jsDoc != "" {
		b.WriteString(jsDoc)
		b.WriteString("\n")
	}

	params := GenerateParams(sig.Params)

	// Use named interface for object returns, otherwise use the type directly
	var returnType string
	if len(sig.Returns.Fields) > 0 {
		returnType = InterfaceName(sig.Name)
	} else {
		returnType = sig.Returns.Type
	}

	b.WriteString("declare global {\n")
	b.WriteString("  interface Window {\n")
	b.WriteString("    ")
	b.WriteString(sig.Name)
	b.WriteString("(")
	b.WriteString(params)
	b.WriteString("): ")
	b.WriteString(returnType)
	b.WriteString(";\n")
	b.WriteString("  }\n")
	// Also declare as global var for Node.js/globalThis access
	b.WriteString("  var ")
	b.WriteString(sig.Name)
	b.WriteString(": (")
	b.WriteString(params)
	b.WriteString(") => ")
	b.WriteString(returnType)
	b.WriteString(";\n")
	b.WriteString("}")

	return b.String()
}

// GenerateJSDoc creates JSDoc comment block with description and examples.
func GenerateJSDoc(sig extractor.FunctionSignature) string {
	if sig.Doc == "" && len(sig.Examples) == 0 {
		return ""
	}

	var b strings.Builder
	b.WriteString("/**")

	if sig.Doc != "" {
		b.WriteString("\n * ")
		b.WriteString(sig.Doc)
	}

	if len(sig.Examples) > 0 {
		if sig.Doc != "" {
			b.WriteString("\n *")
		}
		for _, ex := range sig.Examples {
			b.WriteString("\n * @example\n")
			b.WriteString(FormatExample(sig, ex))
		}
	}

	b.WriteString("\n */")
	return b.String()
}

// GenerateParams formats the parameter list as TypeScript.
func GenerateParams(params []extractor.Parameter) string {
	if len(params) == 0 {
		return ""
	}

	parts := make([]string, len(params))
	for i, p := range params {
		parts[i] = fmt.Sprintf("%s: %s", p.Name, p.Type)
	}
	return strings.Join(parts, ", ")
}

// GenerateReturnType formats the return type as TypeScript.
// Type is always set by ExtractReturnType, so we just return it directly.
func GenerateReturnType(ret extractor.ReturnType) string {
	return ret.Type
}

// FormatExample formats a single example for JSDoc.
func FormatExample(sig extractor.FunctionSignature, ex extractor.Example) string {
	var b strings.Builder

	if ex.Name != "" {
		b.WriteString(" * // ")
		b.WriteString(ex.Name)
		b.WriteString("\n")
	}

	b.WriteString(" * ")
	b.WriteString(sig.Name)
	b.WriteString("(")
	b.WriteString(strings.Join(ex.Args, ", "))
	b.WriteString(")")

	return b.String()
}

// GenerateInterface creates a named interface for object return types.
// Returns empty string if the function doesn't return an object type.
func GenerateInterface(sig extractor.FunctionSignature) string {
	if len(sig.Returns.Fields) == 0 {
		return ""
	}

	var b strings.Builder
	b.WriteString("interface ")
	b.WriteString(InterfaceName(sig.Name))
	b.WriteString(" {\n")

	for _, field := range sig.Returns.Fields {
		b.WriteString("  ")
		b.WriteString(field.Name)
		b.WriteString(": ")
		b.WriteString(field.Type)
		b.WriteString(";\n")
	}

	b.WriteString("}")
	return b.String()
}

// InterfaceName converts a function name to a result interface name.
// e.g., "formatUser" -> "FormatUserResult", "getInfo" -> "GetInfoResult"
func InterfaceName(funcName string) string {
	if funcName == "" {
		return "Result"
	}
	// Capitalize first letter and append "Result"
	return strings.ToUpper(funcName[:1]) + funcName[1:] + "Result"
}
