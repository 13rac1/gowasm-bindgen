// Package generator creates TypeScript client code for Go WASM functions.
//
// Two modes are supported:
//   - Sync mode: class that calls globalThis functions directly
//   - Worker mode: class that communicates via Web Worker
//
// Go functions returning (T, error) automatically throw in TypeScript
// using the __error field convention defined by ErrorFieldName.
package generator

import (
	"fmt"
	"strings"

	"github.com/13rac1/gowasm-bindgen/internal/parser"
)

// tsErrorCheck is the TypeScript code that checks for Go errors passed through WASM.
const tsErrorCheck = `    if (result && typeof result === 'object' && '` + ErrorFieldName + `' in result) {
      throw new Error((result as { ` + ErrorFieldName + `: string }).` + ErrorFieldName + `);
    }
`

// Generate creates TypeScript class-based client for sync mode.
// This generates a class that wraps globalThis function calls.
func Generate(parsed *parser.ParsedFile, outputFile, className string) string {

	var b strings.Builder
	b.WriteString(GenerateHeader(parsed.Package, outputFile))
	b.WriteString("\n\n")

	// Generate named interfaces for struct return types
	for _, fn := range parsed.Functions {
		if iface := GenerateInterfaceForFunction(fn, parsed.Types); iface != "" {
			b.WriteString(iface)
			b.WriteString("\n\n")
		}
	}

	// Generate the class
	b.WriteString(GenerateClass(parsed.Functions, className))

	return b.String()
}

// GenerateHeader creates the file header comment.
func GenerateHeader(packageName, outputFile string) string {
	return fmt.Sprintf(`// %s - Generated by gowasm-bindgen -m sync
// Package: %s`, outputFile, packageName)
}

// GenerateClass creates the TypeScript class with sync methods.
func GenerateClass(functions []parser.GoFunction, className string) string {
	var b strings.Builder

	b.WriteString("export class ")
	b.WriteString(className)
	b.WriteString(" {\n")
	b.WriteString("  private constructor() {}\n\n")

	// Static init method - supports both URL (browser) and bytes (Node.js)
	b.WriteString("  static async init(wasmSource: string | BufferSource): Promise<")
	b.WriteString(className)
	b.WriteString("> {\n")
	b.WriteString("    const go = new Go();\n")
	b.WriteString("    let result: WebAssembly.WebAssemblyInstantiatedSource;\n")
	b.WriteString("    if (typeof wasmSource === 'string') {\n")
	b.WriteString("      result = await WebAssembly.instantiateStreaming(fetch(wasmSource), go.importObject);\n")
	b.WriteString("    } else {\n")
	b.WriteString("      result = await WebAssembly.instantiate(wasmSource, go.importObject);\n")
	b.WriteString("    }\n")
	b.WriteString("    void go.run(result.instance);\n")
	b.WriteString("    return new ")
	b.WriteString(className)
	b.WriteString("();\n")
	b.WriteString("  }\n")

	// Instance methods
	for _, fn := range functions {
		b.WriteString("\n")
		b.WriteString(GenerateClassMethod(fn))
	}

	b.WriteString("}\n")
	return b.String()
}

// GenerateClassMethod creates a single instance method that calls globalThis.
func GenerateClassMethod(fn parser.GoFunction) string {
	var b strings.Builder

	// JSDoc if present
	if fn.Doc != "" {
		lines := strings.Split(fn.Doc, "\n")
		b.WriteString("  /**\n")
		for _, line := range lines {
			b.WriteString("   * ")
			b.WriteString(line)
			b.WriteString("\n")
		}
		b.WriteString("   */\n")
	}

	params := GenerateFunctionParams(fn.Params)
	returnType := determineReturnType(fn)
	funcName := lowerFirst(fn.Name)

	b.WriteString("  ")
	b.WriteString(funcName)
	b.WriteString("(")
	b.WriteString(params)
	b.WriteString("): ")
	b.WriteString(returnType)
	b.WriteString(" {\n")

	// Build argument list
	argNames := make([]string, len(fn.Params))
	for i, p := range fn.Params {
		argNames[i] = p.Name
	}
	argsStr := strings.Join(argNames, ", ")

	// Generate function body with error checking
	b.WriteString("    const result = (globalThis as any).")
	b.WriteString(funcName)
	b.WriteString("(")
	b.WriteString(argsStr)
	b.WriteString(");\n")
	b.WriteString(tsErrorCheck)
	b.WriteString("    return result;\n")
	b.WriteString("  }\n")

	return b.String()
}

// GenerateFunctionParams formats the parameter list as TypeScript.
func GenerateFunctionParams(params []parser.GoParameter) string {
	if len(params) == 0 {
		return ""
	}

	parts := make([]string, len(params))
	for i, p := range params {
		parts[i] = fmt.Sprintf("%s: %s", p.Name, parser.GoTypeToTS(p.Type))
	}
	return strings.Join(parts, ", ")
}

// GenerateInterfaceForFunction creates an exported interface if the function returns a struct.
// Returns empty string if the function doesn't return a struct type.
func GenerateInterfaceForFunction(fn parser.GoFunction, types map[string]*parser.GoType) string {
	if len(fn.Returns) == 0 {
		return ""
	}

	// Get the non-error return type
	hasError := fn.Returns[len(fn.Returns)-1].IsError
	if !hasError || len(fn.Returns) > 1 {
		returnType := fn.Returns[0]
		if returnType.Kind == parser.KindStruct {
			return generateStructInterface(InterfaceName(fn.Name), returnType)
		}
	}

	return ""
}

// generateStructInterface creates an interface from a struct type
func generateStructInterface(name string, structType parser.GoType) string {
	var b strings.Builder
	b.WriteString("export interface ")
	b.WriteString(name)
	b.WriteString(" {\n")

	for _, field := range structType.Fields {
		fieldName := field.JSONTag
		if fieldName == "" {
			// Use lowercase first letter
			fieldName = strings.ToLower(field.Name[:1]) + field.Name[1:]
		}

		b.WriteString("  ")
		b.WriteString(fieldName)
		b.WriteString(": ")
		b.WriteString(parser.GoTypeToTS(field.Type))
		b.WriteString(";\n")
	}

	b.WriteString("}")
	return b.String()
}

// InterfaceName converts a function name to a result interface name.
// e.g., "formatUser" -> "FormatUserResult", "getInfo" -> "GetInfoResult"
func InterfaceName(funcName string) string {
	if funcName == "" {
		return "Result"
	}
	// Capitalize first letter and append "Result"
	return strings.ToUpper(funcName[:1]) + funcName[1:] + "Result"
}

// determineReturnType returns the TypeScript return type for a Go function.
// For functions returning (T, error), returns T. For functions returning only error, returns "void".
func determineReturnType(fn parser.GoFunction) string {
	if len(fn.Returns) == 0 {
		return "void"
	}
	lastIsError := fn.Returns[len(fn.Returns)-1].IsError
	if lastIsError && len(fn.Returns) == 1 {
		return "void"
	}
	if fn.Returns[0].Kind == parser.KindStruct {
		return InterfaceName(fn.Name)
	}
	return parser.GoTypeToTS(fn.Returns[0])
}
