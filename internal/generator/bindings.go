package generator

import (
	"fmt"
	"strings"

	"github.com/13rac1/gowasm-bindgen/internal/parser"
)

// ErrorFieldName is the JSON field used to pass Go errors through the WASM boundary.
// When a Go function returns (T, error), the generated binding returns
// map[string]interface{}{ErrorFieldName: err.Error()} on error.
// The TypeScript client checks for this field and throws it as a JavaScript Error.
const ErrorFieldName = "__error"

// GenerateGoBindings generates Go wrapper code for WASM export.
// workerMode determines whether callbacks use postMessage-based invocation (true)
// or direct JS function invocation (false).
func GenerateGoBindings(parsed *parser.ParsedFile, workerMode bool) string {
	var b strings.Builder

	// Header with build constraint for WASM-only compilation
	b.WriteString("//go:build js && wasm\n\n")
	b.WriteString("// Code generated by gowasm-bindgen. DO NOT EDIT.\n\n")
	b.WriteString("package ")
	b.WriteString(parsed.Package)
	b.WriteString("\n\nimport (\n\t\"fmt\"\n\t\"syscall/js\"\n)\n\n")

	// ErrorFieldName constant for error responses
	b.WriteString("const ErrorFieldName = \"")
	b.WriteString(ErrorFieldName)
	b.WriteString("\"\n\n")

	// recoverFunc decorator for panic recovery
	b.WriteString("func recoverFunc(fn func(js.Value, []js.Value) interface{}) js.Func {\n")
	b.WriteString("\treturn js.FuncOf(func(this js.Value, args []js.Value) (ret interface{}) {\n")
	b.WriteString("\t\tdefer func() {\n")
	b.WriteString("\t\t\tif r := recover(); r != nil {\n")
	b.WriteString("\t\t\t\tret = map[string]interface{}{ErrorFieldName: fmt.Sprintf(\"panic: %v\", r)}\n")
	b.WriteString("\t\t\t}\n")
	b.WriteString("\t\t}()\n")
	b.WriteString("\t\treturn fn(this, args)\n")
	b.WriteString("\t})\n")
	b.WriteString("}\n\n")

	// Init function to register all functions
	b.WriteString("func init() {\n")
	for _, fn := range parsed.Functions {
		b.WriteString("\tjs.Global().Set(\"")
		b.WriteString(lowerFirst(fn.Name))
		b.WriteString("\", recoverFunc(wasm")
		b.WriteString(fn.Name)
		b.WriteString("))\n")
	}
	b.WriteString("}\n\n")

	// Generate wrapper for each function
	for _, fn := range parsed.Functions {
		b.WriteString(generateWrapperFunction(fn, workerMode))
		b.WriteString("\n\n")
	}

	return b.String()
}

// generateWrapperFunction generates a single WASM wrapper function
func generateWrapperFunction(fn parser.GoFunction, workerMode bool) string {
	var b strings.Builder

	// Function signature
	b.WriteString("func wasm")
	b.WriteString(fn.Name)
	b.WriteString("(_ js.Value, args []js.Value) interface{} {\n")

	// Extract parameters
	for i, param := range fn.Params {
		b.WriteString("\t")
		b.WriteString(param.Name)
		b.WriteString(" := ")
		b.WriteString(parser.GoTypeToJSExtraction(param.Type, fmt.Sprintf("args[%d]", i), workerMode))
		b.WriteString("\n")
	}

	// Call the actual function
	b.WriteString("\t")

	// Handle return values
	hasError := len(fn.Returns) > 0 && fn.Returns[len(fn.Returns)-1].IsError
	hasNonErrorReturn := len(fn.Returns) > 0 && (!hasError || len(fn.Returns) > 1)

	if hasNonErrorReturn {
		if hasError {
			b.WriteString("result, err")
		} else {
			b.WriteString("result")
		}
		b.WriteString(" := ")
	} else if hasError {
		b.WriteString("err := ")
	}

	b.WriteString(fn.Name)
	b.WriteString("(")

	// Pass parameters
	paramNames := make([]string, len(fn.Params))
	for i, param := range fn.Params {
		paramNames[i] = param.Name
	}
	b.WriteString(strings.Join(paramNames, ", "))
	b.WriteString(")\n")

	// Handle errors
	if hasError {
		b.WriteString("\tif err != nil {\n")
		b.WriteString("\t\treturn map[string]interface{}{ErrorFieldName: err.Error()}\n")
		b.WriteString("\t}\n")
	}

	// Return result
	b.WriteString("\t")
	if hasNonErrorReturn {
		// Get the non-error return type
		returnType := fn.Returns[0]
		b.WriteString("return ")
		b.WriteString(parser.GoTypeToJSReturn(returnType, "result"))
		b.WriteString("\n")
	} else {
		b.WriteString("return nil\n")
	}

	b.WriteString("}")

	return b.String()
}

// lowerFirst converts first letter to lowercase
func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}
