package generator

import (
	"strings"
	"testing"

	"github.com/13rac1/gowasm-bindgen/internal/extractor"
)

func TestGenerateWorker(t *testing.T) {
	worker := GenerateWorker()

	// Check key parts of the worker
	if !strings.Contains(worker, "importScripts('wasm_exec.js')") {
		t.Error("worker should import wasm_exec.js")
	}
	if !strings.Contains(worker, "self.onmessage") {
		t.Error("worker should have onmessage handler")
	}
	if !strings.Contains(worker, "self.postMessage({ type: 'ready' })") {
		t.Error("worker should post ready message")
	}
}

func TestGenerateClient(t *testing.T) {
	sigs := []extractor.FunctionSignature{
		{
			Name: "greet",
			Params: []extractor.Parameter{
				{Name: "name", Type: "string"},
			},
			Returns: extractor.ReturnType{Type: "string"},
		},
		{
			Name: "formatUser",
			Params: []extractor.Parameter{
				{Name: "name", Type: "string"},
				{Name: "age", Type: "number"},
			},
			Returns: extractor.ReturnType{
				Type: "{displayName: string, status: string}",
				Fields: []extractor.Field{
					{Name: "displayName", Type: "string"},
					{Name: "status", Type: "string"},
				},
			},
		},
	}

	client := GenerateClient(sigs, "wasm")

	// Check header
	if !strings.Contains(client, "// client.ts - Generated by gowasm-bindgen") {
		t.Error("client should have header comment")
	}
	if !strings.Contains(client, "// Package: wasm") {
		t.Error("client should have package comment")
	}

	// Check class structure
	if !strings.Contains(client, "export class Wasm {") {
		t.Error("client should have Wasm class")
	}

	// Check init method
	if !strings.Contains(client, "static async init(workerUrl: string): Promise<Wasm>") {
		t.Error("client should have static init method")
	}

	// Check private constructor
	if !strings.Contains(client, "private constructor(worker: Worker)") {
		t.Error("client should have private constructor")
	}

	// Check terminate method
	if !strings.Contains(client, "terminate(): void") {
		t.Error("client should have terminate method")
	}

	// Check method for greet
	if !strings.Contains(client, "greet(name: string): Promise<string>") {
		t.Error("client should have greet method")
	}
	if !strings.Contains(client, `return this.call<string>("greet", [name])`) {
		t.Error("client should call greet with correct args")
	}

	// Check interface for object return
	if !strings.Contains(client, "export interface FormatUserResult") {
		t.Error("client should have FormatUserResult interface")
	}

	// Check method for formatUser
	if !strings.Contains(client, "formatUser(name: string, age: number): Promise<FormatUserResult>") {
		t.Error("client should have formatUser method")
	}
}

func TestGenerateClientWithDifferentPackage(t *testing.T) {
	sigs := []extractor.FunctionSignature{
		{
			Name:    "add",
			Params:  []extractor.Parameter{{Name: "a", Type: "number"}, {Name: "b", Type: "number"}},
			Returns: extractor.ReturnType{Type: "number"},
		},
	}

	client := GenerateClient(sigs, "calculator")

	// Check class name from package
	if !strings.Contains(client, "export class Calculator {") {
		t.Error("client should have Calculator class")
	}
	if !strings.Contains(client, "static async init(workerUrl: string): Promise<Calculator>") {
		t.Error("client should have init returning Calculator")
	}
}

func TestGenerateWorkerClassMethod(t *testing.T) {
	tests := []struct {
		name string
		sig  extractor.FunctionSignature
		want string
	}{
		{
			name: "simple function",
			sig: extractor.FunctionSignature{
				Name: "greet",
				Params: []extractor.Parameter{
					{Name: "name", Type: "string"},
				},
				Returns: extractor.ReturnType{Type: "string"},
			},
			want: "greet(name: string): Promise<string>",
		},
		{
			name: "multiple params",
			sig: extractor.FunctionSignature{
				Name: "calculate",
				Params: []extractor.Parameter{
					{Name: "a", Type: "number"},
					{Name: "b", Type: "number"},
					{Name: "op", Type: "string"},
				},
				Returns: extractor.ReturnType{Type: "number"},
			},
			want: "calculate(a: number, b: number, op: string): Promise<number>",
		},
		{
			name: "object return",
			sig: extractor.FunctionSignature{
				Name: "getUser",
				Params: []extractor.Parameter{
					{Name: "id", Type: "number"},
				},
				Returns: extractor.ReturnType{
					Type: "{name: string}",
					Fields: []extractor.Field{
						{Name: "name", Type: "string"},
					},
				},
			},
			want: "getUser(id: number): Promise<GetUserResult>",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := GenerateWorkerClassMethod(tt.sig)
			if !strings.Contains(got, tt.want) {
				t.Errorf("GenerateWorkerClassMethod() = %q, want to contain %q", got, tt.want)
			}
		})
	}
}
