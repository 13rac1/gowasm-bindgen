package generator

import (
	"strings"
	"testing"

	"github.com/13rac1/gowasm-bindgen/internal/extractor"
)

func TestGenerateWorker(t *testing.T) {
	worker := GenerateWorker()

	// Check key parts of the worker
	if !strings.Contains(worker, "importScripts('wasm_exec.js')") {
		t.Error("worker should import wasm_exec.js")
	}
	if !strings.Contains(worker, "self.onmessage") {
		t.Error("worker should have onmessage handler")
	}
	if !strings.Contains(worker, "self.postMessage({ type: 'ready' })") {
		t.Error("worker should post ready message")
	}
}

func TestGenerateClient(t *testing.T) {
	sigs := []extractor.FunctionSignature{
		{
			Name: "greet",
			Params: []extractor.Parameter{
				{Name: "name", Type: "string"},
			},
			Returns: extractor.ReturnType{Type: "string"},
		},
		{
			Name: "formatUser",
			Params: []extractor.Parameter{
				{Name: "name", Type: "string"},
				{Name: "age", Type: "number"},
			},
			Returns: extractor.ReturnType{
				Type: "{displayName: string, status: string}",
				Fields: []extractor.Field{
					{Name: "displayName", Type: "string"},
					{Name: "status", Type: "string"},
				},
			},
		},
	}

	client := GenerateClient(sigs)

	// Check header
	if !strings.Contains(client, "Generated by gowasm-bindgen --worker") {
		t.Error("client should have header comment")
	}

	// Check init function
	if !strings.Contains(client, "export function init(workerUrl: string): Promise<void>") {
		t.Error("client should have init function")
	}

	// Check terminate function
	if !strings.Contains(client, "export function terminate(): void") {
		t.Error("client should have terminate function")
	}

	// Check function wrapper for greet
	if !strings.Contains(client, "export function greet(name: string): Promise<string>") {
		t.Error("client should have greet function")
	}
	if !strings.Contains(client, `return call<string>("greet", [name])`) {
		t.Error("client should call greet with correct args")
	}

	// Check interface for object return
	if !strings.Contains(client, "export interface FormatUserResult") {
		t.Error("client should have FormatUserResult interface")
	}

	// Check function wrapper for formatUser
	if !strings.Contains(client, "export function formatUser(name: string, age: number): Promise<FormatUserResult>") {
		t.Error("client should have formatUser function")
	}
}

func TestGenerateClientFunction(t *testing.T) {
	tests := []struct {
		name string
		sig  extractor.FunctionSignature
		want string
	}{
		{
			name: "simple function",
			sig: extractor.FunctionSignature{
				Name: "greet",
				Params: []extractor.Parameter{
					{Name: "name", Type: "string"},
				},
				Returns: extractor.ReturnType{Type: "string"},
			},
			want: "export function greet(name: string): Promise<string>",
		},
		{
			name: "multiple params",
			sig: extractor.FunctionSignature{
				Name: "calculate",
				Params: []extractor.Parameter{
					{Name: "a", Type: "number"},
					{Name: "b", Type: "number"},
					{Name: "op", Type: "string"},
				},
				Returns: extractor.ReturnType{Type: "number"},
			},
			want: "export function calculate(a: number, b: number, op: string): Promise<number>",
		},
		{
			name: "object return",
			sig: extractor.FunctionSignature{
				Name: "getUser",
				Params: []extractor.Parameter{
					{Name: "id", Type: "number"},
				},
				Returns: extractor.ReturnType{
					Type: "{name: string}",
					Fields: []extractor.Field{
						{Name: "name", Type: "string"},
					},
				},
			},
			want: "export function getUser(id: number): Promise<GetUserResult>",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := GenerateClientFunction(tt.sig)
			if !strings.Contains(got, tt.want) {
				t.Errorf("GenerateClientFunction() = %q, want to contain %q", got, tt.want)
			}
		})
	}
}

func TestGenerateExportedInterface(t *testing.T) {
	tests := []struct {
		name string
		sig  extractor.FunctionSignature
		want string
	}{
		{
			name: "no fields returns empty",
			sig: extractor.FunctionSignature{
				Name:    "greet",
				Returns: extractor.ReturnType{Type: "string"},
			},
			want: "",
		},
		{
			name: "object return generates interface",
			sig: extractor.FunctionSignature{
				Name: "formatUser",
				Returns: extractor.ReturnType{
					Type: "{displayName: string, status: string}",
					Fields: []extractor.Field{
						{Name: "displayName", Type: "string"},
						{Name: "status", Type: "string"},
					},
				},
			},
			want: "export interface FormatUserResult {\n  displayName: string;\n  status: string;\n}",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := GenerateExportedInterface(tt.sig)
			if got != tt.want {
				t.Errorf("GenerateExportedInterface() = %q, want %q", got, tt.want)
			}
		})
	}
}
