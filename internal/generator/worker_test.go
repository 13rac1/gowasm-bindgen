package generator

import (
	"strings"
	"testing"

	"github.com/13rac1/gowasm-bindgen/internal/parser"
)

func TestGenerateWorker(t *testing.T) {
	worker := GenerateWorker("module.wasm")

	// Check key parts of the worker
	if !strings.Contains(worker, "importScripts('wasm_exec.js')") {
		t.Error("worker should import wasm_exec.js")
	}
	if !strings.Contains(worker, "self.onmessage") {
		t.Error("worker should have onmessage handler")
	}
	if !strings.Contains(worker, "self.postMessage({ type: 'ready' })") {
		t.Error("worker should post ready message")
	}
	if !strings.Contains(worker, "fetch('module.wasm')") {
		t.Error("worker should fetch module.wasm")
	}
}

func TestGenerateWorkerCustomPath(t *testing.T) {
	tests := []struct {
		name     string
		wasmPath string
		want     string
	}{
		{"default", "module.wasm", "fetch('module.wasm')"},
		{"relative", "./app.wasm", "fetch('./app.wasm')"},
		{"absolute", "/wasm/app.wasm", "fetch('/wasm/app.wasm')"},
		{"url", "https://example.com/app.wasm", "fetch('https://example.com/app.wasm')"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			worker := GenerateWorker(tt.wasmPath)
			if !strings.Contains(worker, tt.want) {
				t.Errorf("GenerateWorker(%q) should contain %q", tt.wasmPath, tt.want)
			}
		})
	}
}

func TestGenerateClient(t *testing.T) {
	parsed := &parser.ParsedFile{
		Package: "wasm",
		Functions: []parser.GoFunction{
			{
				Name: "Greet",
				Params: []parser.GoParameter{
					{Name: "name", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}},
				},
				Returns: []parser.GoType{
					{Name: "string", Kind: parser.KindPrimitive},
				},
			},
			{
				Name: "FormatUser",
				Params: []parser.GoParameter{
					{Name: "name", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}},
					{Name: "age", Type: parser.GoType{Name: "int", Kind: parser.KindPrimitive}},
				},
				Returns: []parser.GoType{
					{
						Name: "User",
						Kind: parser.KindStruct,
						Fields: []parser.GoField{
							{Name: "DisplayName", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}, JSONTag: "displayName"},
							{Name: "Status", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}, JSONTag: "status"},
						},
					},
				},
			},
		},
		Types: map[string]*parser.GoType{},
	}

	client := GenerateClient(parsed)

	// Check header
	if !strings.Contains(client, "// client.ts - Generated by gowasm-bindgen") {
		t.Error("client should have header comment")
	}
	if !strings.Contains(client, "// Package: wasm") {
		t.Error("client should have package comment")
	}

	// Check class structure
	if !strings.Contains(client, "export class Wasm {") {
		t.Error("client should have Wasm class")
	}

	// Check init method
	if !strings.Contains(client, "static async init(workerUrl: string): Promise<Wasm>") {
		t.Error("client should have static init method")
	}

	// Check private constructor
	if !strings.Contains(client, "private constructor(worker: Worker)") {
		t.Error("client should have private constructor")
	}

	// Check terminate method
	if !strings.Contains(client, "terminate(): void") {
		t.Error("client should have terminate method")
	}

	// Check method for greet (lowercased)
	if !strings.Contains(client, "greet(name: string): Promise<string>") {
		t.Error("client should have greet method")
	}
	if !strings.Contains(client, `return this.call<string>("greet", [name])`) {
		t.Error("client should call greet with correct args")
	}

	// Check interface for object return
	if !strings.Contains(client, "export interface FormatUserResult") {
		t.Error("client should have FormatUserResult interface")
	}

	// Check method for formatUser (lowercased)
	if !strings.Contains(client, "formatUser(name: string, age: number): Promise<FormatUserResult>") {
		t.Error("client should have formatUser method")
	}
}

func TestGenerateClientWithDifferentPackage(t *testing.T) {
	parsed := &parser.ParsedFile{
		Package: "calculator",
		Functions: []parser.GoFunction{
			{
				Name: "Add",
				Params: []parser.GoParameter{
					{Name: "a", Type: parser.GoType{Name: "int", Kind: parser.KindPrimitive}},
					{Name: "b", Type: parser.GoType{Name: "int", Kind: parser.KindPrimitive}},
				},
				Returns: []parser.GoType{
					{Name: "int", Kind: parser.KindPrimitive},
				},
			},
		},
		Types: map[string]*parser.GoType{},
	}

	client := GenerateClient(parsed)

	// Check class name from package
	if !strings.Contains(client, "export class Calculator {") {
		t.Error("client should have Calculator class")
	}
	if !strings.Contains(client, "static async init(workerUrl: string): Promise<Calculator>") {
		t.Error("client should have init returning Calculator")
	}
}

func TestGenerateWorkerClassMethod(t *testing.T) {
	tests := []struct {
		name string
		fn   parser.GoFunction
		want string
	}{
		{
			name: "simple function",
			fn: parser.GoFunction{
				Name: "Greet",
				Params: []parser.GoParameter{
					{Name: "name", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}},
				},
				Returns: []parser.GoType{
					{Name: "string", Kind: parser.KindPrimitive},
				},
			},
			want: "greet(name: string): Promise<string>",
		},
		{
			name: "multiple params",
			fn: parser.GoFunction{
				Name: "Calculate",
				Params: []parser.GoParameter{
					{Name: "a", Type: parser.GoType{Name: "int", Kind: parser.KindPrimitive}},
					{Name: "b", Type: parser.GoType{Name: "int", Kind: parser.KindPrimitive}},
					{Name: "op", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}},
				},
				Returns: []parser.GoType{
					{Name: "int", Kind: parser.KindPrimitive},
				},
			},
			want: "calculate(a: number, b: number, op: string): Promise<number>",
		},
		{
			name: "object return",
			fn: parser.GoFunction{
				Name: "GetUser",
				Params: []parser.GoParameter{
					{Name: "id", Type: parser.GoType{Name: "int", Kind: parser.KindPrimitive}},
				},
				Returns: []parser.GoType{
					{
						Name: "User",
						Kind: parser.KindStruct,
						Fields: []parser.GoField{
							{Name: "Name", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}},
						},
					},
				},
			},
			want: "getUser(id: number): Promise<GetUserResult>",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := GenerateWorkerClassMethod(tt.fn)
			if !strings.Contains(got, tt.want) {
				t.Errorf("GenerateWorkerClassMethod() = %q, want to contain %q", got, tt.want)
			}
		})
	}
}
