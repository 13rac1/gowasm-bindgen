package generator

import (
	"strings"
	"testing"

	"github.com/13rac1/gowasm-bindgen/internal/extractor"
)

func TestGenerate(t *testing.T) {
	tests := []struct {
		name        string
		sigs        []extractor.FunctionSignature
		packageName string
		want        []string
	}{
		{
			name:        "empty signatures",
			sigs:        []extractor.FunctionSignature{},
			packageName: "wasm",
			want: []string{
				"// client.ts - Generated by gowasm-bindgen --sync",
				"// Package: wasm",
				"export class Wasm",
			},
		},
		{
			name: "single function",
			sigs: []extractor.FunctionSignature{
				{
					Name: "hashData",
					Params: []extractor.Parameter{
						{Name: "data", Type: "string"},
					},
					Returns: extractor.ReturnType{Type: "string"},
				},
			},
			packageName: "wasm",
			want: []string{
				"export class Wasm",
				"static async init(wasmUrl: string): Promise<Wasm>",
				"hashData(data: string): string",
				"return (globalThis as any).hashData(data);",
			},
		},
		{
			name: "multiple functions",
			sigs: []extractor.FunctionSignature{
				{
					Name:    "funcOne",
					Params:  []extractor.Parameter{{Name: "x", Type: "number"}},
					Returns: extractor.ReturnType{Type: "number"},
				},
				{
					Name:    "funcTwo",
					Params:  []extractor.Parameter{{Name: "s", Type: "string"}},
					Returns: extractor.ReturnType{Type: "boolean"},
				},
			},
			packageName: "calculator",
			want: []string{
				"export class Calculator",
				"funcOne(x: number): number",
				"funcTwo(s: string): boolean",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := Generate(tt.sigs, tt.packageName)
			for _, want := range tt.want {
				if !strings.Contains(got, want) {
					t.Errorf("Generate() missing %q in output:\n%s", want, got)
				}
			}
		})
	}
}

func TestGenerateHeader(t *testing.T) {
	got := GenerateHeader("wasm")
	want := []string{
		"client.ts - Generated by gowasm-bindgen --sync",
		"Package: wasm",
	}

	for _, w := range want {
		if !strings.Contains(got, w) {
			t.Errorf("GenerateHeader() missing %q in output", w)
		}
	}
}

func TestGenerateClass(t *testing.T) {
	tests := []struct {
		name      string
		sigs      []extractor.FunctionSignature
		className string
		want      []string
	}{
		{
			name:      "empty class",
			sigs:      []extractor.FunctionSignature{},
			className: "Wasm",
			want: []string{
				"export class Wasm {",
				"private constructor() {}",
				"static async init(wasmUrl: string): Promise<Wasm>",
			},
		},
		{
			name: "class with methods",
			sigs: []extractor.FunctionSignature{
				{
					Name:    "greet",
					Params:  []extractor.Parameter{{Name: "name", Type: "string"}},
					Returns: extractor.ReturnType{Type: "string"},
				},
			},
			className: "Calculator",
			want: []string{
				"export class Calculator {",
				"static async init(wasmUrl: string): Promise<Calculator>",
				"greet(name: string): string",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := GenerateClass(tt.sigs, tt.className)
			for _, w := range tt.want {
				if !strings.Contains(got, w) {
					t.Errorf("GenerateClass() missing %q in output:\n%s", w, got)
				}
			}
		})
	}
}

func TestGenerateClassMethod(t *testing.T) {
	tests := []struct {
		name string
		sig  extractor.FunctionSignature
		want []string
	}{
		{
			name: "simple function",
			sig: extractor.FunctionSignature{
				Name: "hashData",
				Params: []extractor.Parameter{
					{Name: "data", Type: "string"},
				},
				Returns: extractor.ReturnType{Type: "string"},
			},
			want: []string{
				"hashData(data: string): string {",
				"return (globalThis as any).hashData(data);",
			},
		},
		{
			name: "no parameters",
			sig: extractor.FunctionSignature{
				Name:    "getCurrentTime",
				Params:  []extractor.Parameter{},
				Returns: extractor.ReturnType{Type: "number"},
			},
			want: []string{
				"getCurrentTime(): number {",
				"return (globalThis as any).getCurrentTime();",
			},
		},
		{
			name: "object return",
			sig: extractor.FunctionSignature{
				Name: "validate",
				Params: []extractor.Parameter{
					{Name: "input", Type: "string"},
				},
				Returns: extractor.ReturnType{
					Type: "{valid: boolean, hash: string}",
					Fields: []extractor.Field{
						{Name: "valid", Type: "boolean"},
						{Name: "hash", Type: "string"},
					},
				},
			},
			want: []string{
				"validate(input: string): ValidateResult {",
				"return (globalThis as any).validate(input);",
			},
		},
		{
			name: "with documentation",
			sig: extractor.FunctionSignature{
				Name:    "process",
				Params:  []extractor.Parameter{{Name: "data", Type: "string"}},
				Returns: extractor.ReturnType{Type: "string"},
				Doc:     "Process data and return result",
			},
			want: []string{
				"/**",
				"Process data and return result",
				"*/",
				"process(data: string): string {",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := GenerateClassMethod(tt.sig)
			for _, w := range tt.want {
				if !strings.Contains(got, w) {
					t.Errorf("GenerateClassMethod() missing %q in output:\n%s", w, got)
				}
			}
		})
	}
}

func TestGenerateJSDoc(t *testing.T) {
	tests := []struct {
		name string
		sig  extractor.FunctionSignature
		want string
	}{
		{
			name: "no doc no examples",
			sig:  extractor.FunctionSignature{},
			want: "",
		},
		{
			name: "doc only",
			sig: extractor.FunctionSignature{
				Doc: "This function does something",
			},
			want: "/**\n * This function does something\n */",
		},
		{
			name: "examples only",
			sig: extractor.FunctionSignature{
				Name: "test",
				Examples: []extractor.Example{
					{Name: "basic case", Args: []string{`"hello"`}},
				},
			},
			want: "/**\n * @example\n * // basic case\n * test(\"hello\")\n */",
		},
		{
			name: "doc and examples",
			sig: extractor.FunctionSignature{
				Name: "compute",
				Doc:  "Computes a value",
				Examples: []extractor.Example{
					{Name: "simple", Args: []string{"42"}},
				},
			},
			want: "/**\n * Computes a value\n *\n * @example\n * // simple\n * compute(42)\n */",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := GenerateJSDoc(tt.sig)
			if got != tt.want {
				t.Errorf("GenerateJSDoc() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestGenerateParams(t *testing.T) {
	tests := []struct {
		name   string
		params []extractor.Parameter
		want   string
	}{
		{
			name:   "no parameters",
			params: []extractor.Parameter{},
			want:   "",
		},
		{
			name: "single parameter",
			params: []extractor.Parameter{
				{Name: "data", Type: "string"},
			},
			want: "data: string",
		},
		{
			name: "multiple parameters",
			params: []extractor.Parameter{
				{Name: "input", Type: "string"},
				{Name: "count", Type: "number"},
				{Name: "enabled", Type: "boolean"},
			},
			want: "input: string, count: number, enabled: boolean",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := GenerateParams(tt.params)
			if got != tt.want {
				t.Errorf("GenerateParams() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestFormatExample(t *testing.T) {
	tests := []struct {
		name string
		sig  extractor.FunctionSignature
		ex   extractor.Example
		want string
	}{
		{
			name: "simple example",
			sig:  extractor.FunctionSignature{Name: "hashData"},
			ex: extractor.Example{
				Name: "basic hash",
				Args: []string{`"hello"`},
			},
			want: " * // basic hash\n * hashData(\"hello\")",
		},
		{
			name: "multiple args",
			sig:  extractor.FunctionSignature{Name: "compute"},
			ex: extractor.Example{
				Name: "with numbers",
				Args: []string{"42", "true", `"test"`},
			},
			want: " * // with numbers\n * compute(42, true, \"test\")",
		},
		{
			name: "no name",
			sig:  extractor.FunctionSignature{Name: "process"},
			ex: extractor.Example{
				Args: []string{`"data"`},
			},
			want: " * process(\"data\")",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := FormatExample(tt.sig, tt.ex)
			if got != tt.want {
				t.Errorf("FormatExample() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestGenerateExportedInterface(t *testing.T) {
	tests := []struct {
		name string
		sig  extractor.FunctionSignature
		want string
	}{
		{
			name: "no fields returns empty",
			sig: extractor.FunctionSignature{
				Name:    "greet",
				Returns: extractor.ReturnType{Type: "string"},
			},
			want: "",
		},
		{
			name: "single field",
			sig: extractor.FunctionSignature{
				Name: "getInfo",
				Returns: extractor.ReturnType{
					Type: "{active: boolean}",
					Fields: []extractor.Field{
						{Name: "active", Type: "boolean"},
					},
				},
			},
			want: "export interface GetInfoResult {\n  active: boolean;\n}",
		},
		{
			name: "multiple fields",
			sig: extractor.FunctionSignature{
				Name: "formatUser",
				Returns: extractor.ReturnType{
					Type: "{displayName: string, status: string}",
					Fields: []extractor.Field{
						{Name: "displayName", Type: "string"},
						{Name: "status", Type: "string"},
					},
				},
			},
			want: "export interface FormatUserResult {\n  displayName: string;\n  status: string;\n}",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := GenerateExportedInterface(tt.sig)
			if got != tt.want {
				t.Errorf("GenerateExportedInterface() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestInterfaceName(t *testing.T) {
	tests := []struct {
		funcName string
		want     string
	}{
		{"formatUser", "FormatUserResult"},
		{"getInfo", "GetInfoResult"},
		{"validate", "ValidateResult"},
		{"a", "AResult"},
		{"", "Result"},
	}

	for _, tt := range tests {
		t.Run(tt.funcName, func(t *testing.T) {
			got := InterfaceName(tt.funcName)
			if got != tt.want {
				t.Errorf("InterfaceName(%q) = %q, want %q", tt.funcName, got, tt.want)
			}
		})
	}
}

func TestToClassName(t *testing.T) {
	tests := []struct {
		packageName string
		want        string
	}{
		{"wasm", "Wasm"},
		{"calculator", "Calculator"},
		{"mypackage", "Mypackage"},
		{"", "Wasm"},
	}

	for _, tt := range tests {
		t.Run(tt.packageName, func(t *testing.T) {
			got := toClassName(tt.packageName)
			if got != tt.want {
				t.Errorf("toClassName(%q) = %q, want %q", tt.packageName, got, tt.want)
			}
		})
	}
}
