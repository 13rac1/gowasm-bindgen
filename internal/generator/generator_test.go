package generator

import (
	"strings"
	"testing"

	"github.com/13rac1/gowasm-bindgen/internal/parser"
)

func TestGenerate(t *testing.T) {
	tests := []struct {
		name   string
		parsed *parser.ParsedFile
		want   []string
	}{
		{
			name: "empty functions",
			parsed: &parser.ParsedFile{
				Package:   "wasm",
				Functions: []parser.GoFunction{},
				Types:     map[string]*parser.GoType{},
			},
			want: []string{
				"// client.ts - Generated by gowasm-bindgen --sync",
				"// Package: wasm",
				"export class Wasm",
			},
		},
		{
			name: "single function",
			parsed: &parser.ParsedFile{
				Package: "wasm",
				Functions: []parser.GoFunction{
					{
						Name: "HashData",
						Params: []parser.GoParameter{
							{Name: "data", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}},
						},
						Returns: []parser.GoType{
							{Name: "string", Kind: parser.KindPrimitive},
						},
					},
				},
				Types: map[string]*parser.GoType{},
			},
			want: []string{
				"export class Wasm",
				"static async init(wasmUrl: string): Promise<Wasm>",
				"hashData(data: string): string",
				"const result = (globalThis as any).hashData(data);",
				"throw new Error((result as { __error: string }).__error);",
				"return result;",
			},
		},
		{
			name: "multiple functions",
			parsed: &parser.ParsedFile{
				Package: "calculator",
				Functions: []parser.GoFunction{
					{
						Name:    "FuncOne",
						Params:  []parser.GoParameter{{Name: "x", Type: parser.GoType{Name: "int", Kind: parser.KindPrimitive}}},
						Returns: []parser.GoType{{Name: "int", Kind: parser.KindPrimitive}},
					},
					{
						Name:    "FuncTwo",
						Params:  []parser.GoParameter{{Name: "s", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}}},
						Returns: []parser.GoType{{Name: "bool", Kind: parser.KindPrimitive}},
					},
				},
				Types: map[string]*parser.GoType{},
			},
			want: []string{
				"export class Calculator",
				"funcOne(x: number): number",
				"funcTwo(s: string): boolean",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := Generate(tt.parsed)
			for _, want := range tt.want {
				if !strings.Contains(got, want) {
					t.Errorf("Generate() missing %q in output:\n%s", want, got)
				}
			}
		})
	}
}

func TestGenerateHeader(t *testing.T) {
	got := GenerateHeader("wasm")
	want := []string{
		"client.ts - Generated by gowasm-bindgen --sync",
		"Package: wasm",
	}

	for _, w := range want {
		if !strings.Contains(got, w) {
			t.Errorf("GenerateHeader() missing %q in output", w)
		}
	}
}

func TestGenerateClass(t *testing.T) {
	tests := []struct {
		name      string
		functions []parser.GoFunction
		className string
		want      []string
	}{
		{
			name:      "empty class",
			functions: []parser.GoFunction{},
			className: "Wasm",
			want: []string{
				"export class Wasm {",
				"private constructor() {}",
				"static async init(wasmUrl: string): Promise<Wasm>",
			},
		},
		{
			name: "class with methods",
			functions: []parser.GoFunction{
				{
					Name:    "Greet",
					Params:  []parser.GoParameter{{Name: "name", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}}},
					Returns: []parser.GoType{{Name: "string", Kind: parser.KindPrimitive}},
				},
			},
			className: "Calculator",
			want: []string{
				"export class Calculator {",
				"static async init(wasmUrl: string): Promise<Calculator>",
				"greet(name: string): string",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := GenerateClass(tt.functions, tt.className)
			for _, w := range tt.want {
				if !strings.Contains(got, w) {
					t.Errorf("GenerateClass() missing %q in output:\n%s", w, got)
				}
			}
		})
	}
}

func TestGenerateClassMethod(t *testing.T) {
	tests := []struct {
		name string
		fn   parser.GoFunction
		want []string
	}{
		{
			name: "simple function",
			fn: parser.GoFunction{
				Name: "HashData",
				Params: []parser.GoParameter{
					{Name: "data", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}},
				},
				Returns: []parser.GoType{{Name: "string", Kind: parser.KindPrimitive}},
			},
			want: []string{
				"hashData(data: string): string {",
				"const result = (globalThis as any).hashData(data);",
				"'__error' in result",
				"return result;",
			},
		},
		{
			name: "no parameters",
			fn: parser.GoFunction{
				Name:    "GetCurrentTime",
				Params:  []parser.GoParameter{},
				Returns: []parser.GoType{{Name: "int", Kind: parser.KindPrimitive}},
			},
			want: []string{
				"getCurrentTime(): number {",
				"const result = (globalThis as any).getCurrentTime();",
				"return result;",
			},
		},
		{
			name: "with documentation",
			fn: parser.GoFunction{
				Name:    "Process",
				Params:  []parser.GoParameter{{Name: "data", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}}},
				Returns: []parser.GoType{{Name: "string", Kind: parser.KindPrimitive}},
				Doc:     "Process data and return result",
			},
			want: []string{
				"/**",
				"Process data and return result",
				"*/",
				"process(data: string): string {",
			},
		},
		{
			name: "function with error return",
			fn: parser.GoFunction{
				Name: "Divide",
				Params: []parser.GoParameter{
					{Name: "a", Type: parser.GoType{Name: "int", Kind: parser.KindPrimitive}},
					{Name: "b", Type: parser.GoType{Name: "int", Kind: parser.KindPrimitive}},
				},
				Returns: []parser.GoType{
					{Name: "int", Kind: parser.KindPrimitive},
					{Name: "error", Kind: parser.KindPrimitive, IsError: true},
				},
			},
			want: []string{
				"divide(a: number, b: number): number {",
				"const result = (globalThis as any).divide(a, b);",
				"'__error' in result",
				"throw new Error",
				"return result;",
			},
		},
		{
			name: "function with only error return",
			fn: parser.GoFunction{
				Name:   "Close",
				Params: []parser.GoParameter{},
				Returns: []parser.GoType{
					{Name: "error", Kind: parser.KindPrimitive, IsError: true},
				},
			},
			want: []string{
				"close(): void {",
				"const result = (globalThis as any).close();",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := GenerateClassMethod(tt.fn)
			for _, w := range tt.want {
				if !strings.Contains(got, w) {
					t.Errorf("GenerateClassMethod() missing %q in output:\n%s", w, got)
				}
			}
		})
	}
}

func TestInterfaceName(t *testing.T) {
	tests := []struct {
		funcName string
		want     string
	}{
		{"FormatUser", "FormatUserResult"},
		{"GetInfo", "GetInfoResult"},
		{"Validate", "ValidateResult"},
		{"A", "AResult"},
		{"", "Result"},
	}

	for _, tt := range tests {
		t.Run(tt.funcName, func(t *testing.T) {
			got := InterfaceName(tt.funcName)
			if got != tt.want {
				t.Errorf("InterfaceName(%q) = %q, want %q", tt.funcName, got, tt.want)
			}
		})
	}
}

func TestToClassName(t *testing.T) {
	tests := []struct {
		packageName string
		want        string
	}{
		{"wasm", "Wasm"},
		{"calculator", "Calculator"},
		{"mypackage", "Mypackage"},
		{"", "Wasm"},
	}

	for _, tt := range tests {
		t.Run(tt.packageName, func(t *testing.T) {
			got := toClassName(tt.packageName)
			if got != tt.want {
				t.Errorf("toClassName(%q) = %q, want %q", tt.packageName, got, tt.want)
			}
		})
	}
}

func TestGenerateFunctionParams(t *testing.T) {
	tests := []struct {
		name   string
		params []parser.GoParameter
		want   string
	}{
		{
			name:   "no parameters",
			params: []parser.GoParameter{},
			want:   "",
		},
		{
			name: "single parameter",
			params: []parser.GoParameter{
				{Name: "data", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}},
			},
			want: "data: string",
		},
		{
			name: "multiple parameters",
			params: []parser.GoParameter{
				{Name: "input", Type: parser.GoType{Name: "string", Kind: parser.KindPrimitive}},
				{Name: "count", Type: parser.GoType{Name: "int", Kind: parser.KindPrimitive}},
				{Name: "enabled", Type: parser.GoType{Name: "bool", Kind: parser.KindPrimitive}},
			},
			want: "input: string, count: number, enabled: boolean",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := GenerateFunctionParams(tt.params)
			if got != tt.want {
				t.Errorf("GenerateFunctionParams() = %q, want %q", got, tt.want)
			}
		})
	}
}
